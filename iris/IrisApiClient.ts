//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.3.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @return A JSON object with the key "status" and value "running" (both without the quotes).
     */
    status(): Promise<ApiStatus> {
        let url_ = this.baseUrl + "/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStatus(_response);
        });
    }

    protected processStatus(response: Response): Promise<ApiStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApiStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApiStatus>(null as any);
    }
}

export class ConnectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Connect input with subjects and subject pairs
     * @return default response
     */
    startConnect(body: ConnectScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/connect";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartConnect(_response);
        });
    }

    protected processStartConnect(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the connect investigation.
     * @return default response
     */
    getConnectResult(executionId: string): Promise<ConnectStatus> {
        let url_ = this.baseUrl + "/connect/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectResult(_response);
        });
    }

    protected processGetConnectResult(response: Response): Promise<ConnectStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConnectStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ConnectStatus>(null as any);
    }

    /**
     * @return default response
     */
    getConnectStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/connect/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConnectStatus(_response);
        });
    }

    protected processGetConnectStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class ContactClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param executionId The executionId returned by the start of the contact investigation.
     * @return default response
     */
    getContactResult(executionId: string): Promise<ContactStatus> {
        let url_ = this.baseUrl + "/contact/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactResult(_response);
        });
    }

    protected processGetContactResult(response: Response): Promise<ContactStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactStatus>(null as any);
    }

    /**
     * @param body Contact input with subjects
     * @return Execution started identifier
     */
    startContactInvestigation(body: ContactScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartContactInvestigation(_response);
        });
    }

    protected processStartContactInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return ISO 3166-1 alpha-2 country codes see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
     */
    getCountriesForContact(): Promise<string[]> {
        let url_ = this.baseUrl + "/contact/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCountriesForContact(_response);
        });
    }

    protected processGetCountriesForContact(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param body Contact input with subjects
     * @return Execution started identifier
     */
    startTestContactInvestigation(body: ContactScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/contact/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartTestContactInvestigation(_response);
        });
    }

    protected processStartTestContactInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return default response
     */
    getContactStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/contact/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactStatus(_response);
        });
    }

    protected processGetContactStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class CseRiskClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body A list of one or more subject references, a graph containing those subject(s) and optionally options to enable sub-investigations. A subject is a Person optionally with (annotated) first and last name(s), optionally related to an Account (account id or username is required for social media investigations, username is required for Darknet investigations) and/or a Location.
     * @return Online research ID with which the status or result of the research can be retrieved
     */
    startCSERisk(body: CSERiskScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/cse-risk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartCSERisk(_response);
        });
    }

    protected processStartCSERisk(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied. Input must contain at least one subject.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return default response
     */
    getCSERiskExecutionResult(executionId: string): Promise<CSERiskStatus> {
        let url_ = this.baseUrl + "/cse-risk/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCSERiskExecutionResult(_response);
        });
    }

    protected processGetCSERiskExecutionResult(response: Response): Promise<CSERiskStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CSERiskStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CSERiskStatus>(null as any);
    }

    /**
     * @return default response
     */
    getCSERiskStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/cse-risk/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCSERiskStatus(_response);
        });
    }

    protected processGetCSERiskStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookAccountStatusCheckClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook profile URL or id
     * @return The Facebook account status (one of "online", "suspended" and "disabled") accompanied by the moment the check was performed on Facebook (in milliseconds since epoch)
     */
    startFacebookAccountStatusCheck(body: string): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook-account-status-check";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartFacebookAccountStatusCheck(_response);
        });
    }

    protected processStartFacebookAccountStatusCheck(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return The status of the execution, a result if finished and successful, an error when finished but failed, null when not yet finished
     */
    getFacebookAccountStatusCheckExecutionResult(executionId: string): Promise<FacebookAccountStatusCheckExecutionStatus> {
        let url_ = this.baseUrl + "/facebook-account-status-check/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookAccountStatusCheckExecutionResult(_response);
        });
    }

    protected processGetFacebookAccountStatusCheckExecutionResult(response: Response): Promise<FacebookAccountStatusCheckExecutionStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookAccountStatusCheckExecutionStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookAccountStatusCheckExecutionStatus>(null as any);
    }

    /**
     * @return default response
     */
    getFacebookAccountStatusCheckExecutionStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook-account-status-check/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookAccountStatusCheckExecutionStatus(_response);
        });
    }

    protected processGetFacebookAccountStatusCheckExecutionStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook details input containing the url, accountId or username of the profile to retrieve details from
     * @return Execution started identifier
     */
    startDetailsInvestigation(body: FacebookDetailScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartDetailsInvestigation(_response);
        });
    }

    protected processStartDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getDetailsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailsResult(_response);
        });
    }

    protected processGetDetailsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailsStatus(_response);
        });
    }

    protected processGetDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookEventClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Url of event to extract details from
     * @return Execution started identifier
     */
    startEventDetailsInvestigation(body: EventDetailScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/event/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartEventDetailsInvestigation(_response);
        });
    }

    protected processStartEventDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getEventDetailsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/event/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventDetailsResult(_response);
        });
    }

    protected processGetEventDetailsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getEventDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/event/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventDetailsStatus(_response);
        });
    }

    protected processGetEventDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }

    /**
     * @param body Url of event to extract posts from
     * @return Execution started identifier
     */
    startEventPostsInvestigation(body: EventPostsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/event/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartEventPostsInvestigation(_response);
        });
    }

    protected processStartEventPostsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getEventPostsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/event/posts/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventPostsResult(_response);
        });
    }

    protected processGetEventPostsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getEventPostsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/event/posts/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventPostsStatus(_response);
        });
    }

    protected processGetEventPostsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }

    /**
     * @param body Keywords to be used for searching
     * @return Execution started identifier
     */
    startEventSearchInvestigation(body: EventSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/event/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartEventSearchInvestigation(_response);
        });
    }

    protected processStartEventSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getEventSearchResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/event/search/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventSearchResult(_response);
        });
    }

    protected processGetEventSearchResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getEventSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/event/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventSearchStatus(_response);
        });
    }

    protected processGetEventSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookFriendsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook friends input with subject information
     * @return Execution started identifier
     */
    startFacebookFriendsInvestigation(body: FacebookFriendsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/friends";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartFacebookFriendsInvestigation(_response);
        });
    }

    protected processStartFacebookFriendsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param body Facebook friends input with subject information
     * @return Execution started identifier
     */
    startTestFacebookFriendsInvestigation(body: FacebookFriendsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/friends/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartTestFacebookFriendsInvestigation(_response);
        });
    }

    protected processStartTestFacebookFriendsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getFacebookFriendsResult(investigationId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/friends/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookFriendsResult(_response);
        });
    }

    protected processGetFacebookFriendsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getFacebookFriendsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/friends/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookFriendsStatus(_response);
        });
    }

    protected processGetFacebookFriendsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookGroupClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Url of group to extract details from
     * @return Execution started identifier
     */
    startGroupDetailsInvestigation(body: GroupDetailScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/group/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGroupDetailsInvestigation(_response);
        });
    }

    protected processStartGroupDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the facebook investigation.
     * @return default response
     */
    getGroupDetailsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/group/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupDetailsResult(_response);
        });
    }

    protected processGetGroupDetailsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getGroupDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/group/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupDetailsStatus(_response);
        });
    }

    protected processGetGroupDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }

    /**
     * @param body Url of Facebook group to extract posts from
     * @return Execution started identifier
     */
    startGroupPostsInvestigation(body: GroupPostsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/group/posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGroupPostsInvestigation(_response);
        });
    }

    protected processStartGroupPostsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getGroupPostsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/group/posts/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupPostsResult(_response);
        });
    }

    protected processGetGroupPostsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getGroupPostsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/group/posts/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupPostsStatus(_response);
        });
    }

    protected processGetGroupPostsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }

    /**
     * @param body Keywords to be used for searching
     * @return Execution started identifier
     */
    startGroupSearchInvestigation(body: GroupSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/group/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGroupSearchInvestigation(_response);
        });
    }

    protected processStartGroupSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getGroupSearchResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/group/search/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupSearchResult(_response);
        });
    }

    protected processGetGroupSearchResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getGroupSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/group/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGroupSearchStatus(_response);
        });
    }

    protected processGetGroupSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookPageClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook page details input containing the url of the page to retrieve details from
     * @return Execution started identifier
     */
    startPageDetailsInvestigation(body: PageDetailScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/page/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartPageDetailsInvestigation(_response);
        });
    }

    protected processStartPageDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getPageDetailsResult(executionId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/page/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPageDetailsResult(_response);
        });
    }

    protected processGetPageDetailsResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getPageDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/page/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPageDetailsStatus(_response);
        });
    }

    protected processGetPageDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookPageSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook page search input with subject information
     * @return Execution started identifier
     */
    startFacebookPageSearchInvestigation(body: FacebookPageSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/page/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartFacebookPageSearchInvestigation(_response);
        });
    }

    protected processStartFacebookPageSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getFacebookPageSearchResult(investigationId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/page/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookPageSearchResult(_response);
        });
    }

    protected processGetFacebookPageSearchResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getFacebookPageSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/page/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookPageSearchStatus(_response);
        });
    }

    protected processGetFacebookPageSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class FacebookProfileSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Facebook profile search input with subject information
     * @return Execution started identifier
     */
    startFacebookProfileSearchInvestigation(body: FacebookProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/profile/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartFacebookProfileSearchInvestigation(_response);
        });
    }

    protected processStartFacebookProfileSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param body Facebook profile search input with subject information
     * @return Execution started identifier
     */
    startFacebookTestProfileSearchInvestigation(body: FacebookProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/facebook/profile/search/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartFacebookTestProfileSearchInvestigation(_response);
        });
    }

    protected processStartFacebookTestProfileSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getFacebookProfileSearchResult(investigationId: string): Promise<FacebookStatus> {
        let url_ = this.baseUrl + "/facebook/profile/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookProfileSearchResult(_response);
        });
    }

    protected processGetFacebookProfileSearchResult(response: Response): Promise<FacebookStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FacebookStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FacebookStatus>(null as any);
    }

    /**
     * @return default response
     */
    getFacebookProfileSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/facebook/profile/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFacebookProfileSearchStatus(_response);
        });
    }

    protected processGetFacebookProfileSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class GoogleSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getGoogleSearchResult(investigationId: string): Promise<GoogleStatus> {
        let url_ = this.baseUrl + "/google/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGoogleSearchResult(_response);
        });
    }

    protected processGetGoogleSearchResult(response: Response): Promise<GoogleStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GoogleStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GoogleStatus>(null as any);
    }

    /**
     * @param body Google search input with subject information
     * @return Execution started identifier
     */
    startGoogleSearchInvestigation(body: GoogleSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/google/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartGoogleSearchInvestigation(_response);
        });
    }

    protected processStartGoogleSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }
}

export class InstagramProfileDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Instagram profile details input with Instagram account.
     * @return Execution started identifier
     */
    startProfileDetailsDetailsInvestigation(body: InstagramProfileDetailsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/instagram/profile/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartProfileDetailsDetailsInvestigation(_response);
        });
    }

    protected processStartProfileDetailsDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the Instagram investigation.
     * @return default response
     */
    getProfileDetailsResult(executionId: string): Promise<InstagramStatus> {
        let url_ = this.baseUrl + "/instagram/profile/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfileDetailsResult(_response);
        });
    }

    protected processGetProfileDetailsResult(response: Response): Promise<InstagramStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstagramStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InstagramStatus>(null as any);
    }

    /**
     * @return default response
     */
    getProfileDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/instagram/profile/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfileDetailsStatus(_response);
        });
    }

    protected processGetProfileDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class InstagramProfileSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Instagram profile search input with subject information
     * @return Execution started identifier
     */
    startInstagramSearchInvestigation(body: InstagramProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/instagram/profile/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartInstagramSearchInvestigation(_response);
        });
    }

    protected processStartInstagramSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getInstagramProfileSearchResult(investigationId: string): Promise<InstagramStatus> {
        let url_ = this.baseUrl + "/instagram/profile/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstagramProfileSearchResult(_response);
        });
    }

    protected processGetInstagramProfileSearchResult(response: Response): Promise<InstagramStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InstagramStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InstagramStatus>(null as any);
    }

    /**
     * @return default response
     */
    getInstagramProfileSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/instagram/profile/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstagramProfileSearchStatus(_response);
        });
    }

    protected processGetInstagramProfileSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class LinkedinDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body LinkedIn details input containing the url or username of the profile to retrieve details from
     * @return Execution started identifier
     */
    startDetailsInvestigation_1(body: LinkedInDetailScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/linkedin/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartDetailsInvestigation_1(_response);
        });
    }

    protected processStartDetailsInvestigation_1(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the investigation.
     * @return default response
     */
    getDetailsResult_1(executionId: string): Promise<LinkedInStatus> {
        let url_ = this.baseUrl + "/linkedin/details/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailsResult_1(_response);
        });
    }

    protected processGetDetailsResult_1(response: Response): Promise<LinkedInStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkedInStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkedInStatus>(null as any);
    }

    /**
     * @return default response
     */
    getDetailsStatus_1(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/linkedin/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDetailsStatus_1(_response);
        });
    }

    protected processGetDetailsStatus_1(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class LinkedinProfileSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body LinkedIn profile search input with subject information
     * @return Execution started identifier
     */
    startLinkedInProfileSearchInvestigation(body: LinkedInProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/linkedin/profile/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartLinkedInProfileSearchInvestigation(_response);
        });
    }

    protected processStartLinkedInProfileSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getLinkedInProfileSearchResult(investigationId: string): Promise<LinkedInStatus> {
        let url_ = this.baseUrl + "/linkedin/profile/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkedInProfileSearchResult(_response);
        });
    }

    protected processGetLinkedInProfileSearchResult(response: Response): Promise<LinkedInStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LinkedInStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LinkedInStatus>(null as any);
    }

    /**
     * @param body LinkedIn profile search input with subject information
     * @return Execution started identifier
     */
    startLinkedInTestProfileSearchInvestigation(body: LinkedInProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/linkedin/profile/search/test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartLinkedInTestProfileSearchInvestigation(_response);
        });
    }

    protected processStartLinkedInTestProfileSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return default response
     */
    getLinkedInProfileSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/linkedin/profile/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLinkedInProfileSearchStatus(_response);
        });
    }

    protected processGetLinkedInProfileSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class RiskClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param locale The locale for which the risk categories should be listed.
     * @return The risk categories available with this locale
     */
    getCategories(locale: string): Promise<string[]> {
        let url_ = this.baseUrl + "/risk/locales/{locale}/categories";
        if (locale === undefined || locale === null)
            throw new Error("The parameter 'locale' must be defined.");
        url_ = url_.replace("{locale}", encodeURIComponent("" + locale));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategories(_response);
        });
    }

    protected processGetCategories(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Invalid locale supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @return Locales with language and region sub tags as defined in https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry (but in all upper case).
     */
    getLocales(): Promise<string[]> {
        let url_ = this.baseUrl + "/risk/locales";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLocales(_response);
        });
    }

    protected processGetLocales(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    /**
     * @param executionId The executionId returned by the start of the risk investigation.
     * @return default response
     */
    getRiskResult(executionId: string): Promise<RiskStatus> {
        let url_ = this.baseUrl + "/risk/{executionId}";
        if (executionId === undefined || executionId === null)
            throw new Error("The parameter 'executionId' must be defined.");
        url_ = url_.replace("{executionId}", encodeURIComponent("" + executionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRiskResult(_response);
        });
    }

    protected processGetRiskResult(response: Response): Promise<RiskStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RiskStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RiskStatus>(null as any);
    }

    /**
     * @param body Risk input with subjects
     * @return Execution started identifier
     */
    startInvestigation(body: RiskScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/risk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartInvestigation(_response);
        });
    }

    protected processStartInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @return default response
     */
    getRiskStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/risk/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRiskStatus(_response);
        });
    }

    protected processGetRiskStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class TiktokProfileDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body TikTok details input with account information
     * @return Execution started identifier
     */
    startTiktokDetailsInvestigation(body: TiktokProfileDetailsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/tiktok/profile/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartTiktokDetailsInvestigation(_response);
        });
    }

    protected processStartTiktokDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getTiktokProfileDetailsResult(investigationId: string): Promise<TiktokStatus> {
        let url_ = this.baseUrl + "/tiktok/profile/details/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTiktokProfileDetailsResult(_response);
        });
    }

    protected processGetTiktokProfileDetailsResult(response: Response): Promise<TiktokStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TiktokStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TiktokStatus>(null as any);
    }

    /**
     * @return default response
     */
    getTiktokProfileDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/tiktok/profile/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTiktokProfileDetailsStatus(_response);
        });
    }

    protected processGetTiktokProfileDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class TiktokProfileSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body TikTok profile search input with subject information
     * @return Execution started identifier
     */
    startTiktokSearchInvestigation(body: TiktokProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/tiktok/profile/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartTiktokSearchInvestigation(_response);
        });
    }

    protected processStartTiktokSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getTiktokProfileSearchResult(investigationId: string): Promise<TiktokStatus> {
        let url_ = this.baseUrl + "/tiktok/profile/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTiktokProfileSearchResult(_response);
        });
    }

    protected processGetTiktokProfileSearchResult(response: Response): Promise<TiktokStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TiktokStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TiktokStatus>(null as any);
    }

    /**
     * @return default response
     */
    getInstagramProfileSearchStatus_1(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/tiktok/profile/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInstagramProfileSearchStatus_1(_response);
        });
    }

    protected processGetInstagramProfileSearchStatus_1(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class WebSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body Web search input with subject information
     * @return Execution started identifier
     */
    startWebSearchInvestigation(body: WebSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/web/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartWebSearchInvestigation(_response);
        });
    }

    protected processStartWebSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getWebSearchResult(investigationId: string): Promise<WebSearchStatus> {
        let url_ = this.baseUrl + "/web/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWebSearchResult(_response);
        });
    }

    protected processGetWebSearchResult(response: Response): Promise<WebSearchStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebSearchStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<WebSearchStatus>(null as any);
    }
}

export class YoutubeProfileDetailsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param body YouTube details input with account information
     * @return Execution started identifier
     */
    startYoutubeDetailsInvestigation(body: YoutubeProfileDetailsScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/youtube/profile/details";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartYoutubeDetailsInvestigation(_response);
        });
    }

    protected processStartYoutubeDetailsInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getYoutubeProfileDetailsResult(investigationId: string): Promise<YoutubeStatus> {
        let url_ = this.baseUrl + "/youtube/profile/details/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetYoutubeProfileDetailsResult(_response);
        });
    }

    protected processGetYoutubeProfileDetailsResult(response: Response): Promise<YoutubeStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YoutubeStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<YoutubeStatus>(null as any);
    }

    /**
     * @return default response
     */
    getYoutubeProfileDetailsStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/youtube/profile/details/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetYoutubeProfileDetailsStatus(_response);
        });
    }

    protected processGetYoutubeProfileDetailsStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }
}

export class YoutubeProfileSearchClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://iris.web-iq.com/api";
    }

    /**
     * @param investigationId The investigationId returned by the start of the investigation.
     * @return default response
     */
    getYoutubeProfileSearchResult(investigationId: string): Promise<YoutubeStatus> {
        let url_ = this.baseUrl + "/youtube/profile/search/{investigationId}";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetYoutubeProfileSearchResult(_response);
        });
    }

    protected processGetYoutubeProfileSearchResult(response: Response): Promise<YoutubeStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YoutubeStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<YoutubeStatus>(null as any);
    }

    /**
     * @return default response
     */
    getYoutubeProfileSearchStatus(investigationId: string): Promise<InvestigationStatus> {
        let url_ = this.baseUrl + "/youtube/profile/search/{investigationId}/status";
        if (investigationId === undefined || investigationId === null)
            throw new Error("The parameter 'investigationId' must be defined.");
        url_ = url_.replace("{investigationId}", encodeURIComponent("" + investigationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetYoutubeProfileSearchStatus(_response);
        });
    }

    protected processGetYoutubeProfileSearchStatus(response: Response): Promise<InvestigationStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvestigationStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvestigationStatus>(null as any);
    }

    /**
     * @param body YouTube profile search input with subject information
     * @return Execution started identifier
     */
    startYoutubeSearchInvestigation(body: YoutubeProfileSearchScope): Promise<ExecutionStarted> {
        let url_ = this.baseUrl + "/youtube/profile/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processStartYoutubeSearchInvestigation(_response);
        });
    }

    protected processStartYoutubeSearchInvestigation(response: Response): Promise<ExecutionStarted> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExecutionStarted.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Invalid input supplied", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExecutionStarted>(null as any);
    }
}

export class ApiStatus implements IApiStatus {
    status?: string;

    [key: string]: any;

    constructor(data?: IApiStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ApiStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ApiStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["status"] = this.status;
        return data;
    }
}

export interface IApiStatus {
    status?: string;

    [key: string]: any;
}

/** Response with an executionId which is a token for retrieving the result of an investigation. */
export class ExecutionStarted implements IExecutionStarted {
    executionId?: string;

    [key: string]: any;

    constructor(data?: IExecutionStarted) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.executionId = _data["executionId"];
        }
    }

    static fromJS(data: any): ExecutionStarted {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutionStarted();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["executionId"] = this.executionId;
        return data;
    }
}

/** Response with an executionId which is a token for retrieving the result of an investigation. */
export interface IExecutionStarted {
    executionId?: string;

    [key: string]: any;
}

/** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
export class Vertex implements IVertex {
    /** Identifier of this vertex; is used to reference this vertex in e.g. an Edge or VertexPair. */
    id?: string;

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: IVertex) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Vertex";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Vertex {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "Account") {
            let result = new Account();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Identity") {
            let result = new Identity();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Comment") {
            let result = new Comment();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Resource") {
            let result = new Resource();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Education") {
            let result = new Education();
            result.init(data);
            return result;
        }
        if (data["_type"] === "EmailAddress") {
            let result = new EmailAddress();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Employment") {
            let result = new Employment();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookAccount") {
            let result = new FacebookAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookEvent") {
            let result = new FacebookEvent();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookGroup") {
            let result = new FacebookGroup();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookPage") {
            let result = new FacebookPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GoogleAccount") {
            let result = new GoogleAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GooglePlace") {
            let result = new GooglePlace();
            result.init(data);
            return result;
        }
        if (data["_type"] === "InstagramAccount") {
            let result = new InstagramAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LegalIdentity") {
            let result = new LegalIdentity();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInAccount") {
            let result = new LinkedInAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInPage") {
            let result = new LinkedInPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Location") {
            let result = new Location();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Organization") {
            let result = new Organization();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Person") {
            let result = new Person();
            result.init(data);
            return result;
        }
        if (data["_type"] === "PhoneNumber") {
            let result = new PhoneNumber();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Review") {
            let result = new Review();
            result.init(data);
            return result;
        }
        if (data["_type"] === "RiskIndicator") {
            let result = new RiskIndicator();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TiktokAccount") {
            let result = new TiktokAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TwitterAccount") {
            let result = new TwitterAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Website") {
            let result = new Website();
            result.init(data);
            return result;
        }
        if (data["_type"] === "YouTubeAccount") {
            let result = new YouTubeAccount();
            result.init(data);
            return result;
        }
        let result = new Vertex();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._discriminator;
        data["id"] = this.id;
        return data;
    }
}

/** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
export interface IVertex {
    /** Identifier of this vertex; is used to reference this vertex in e.g. an Edge or VertexPair. */
    id?: string;

    [key: string]: any;
}

export class Identity extends Vertex implements IIdentity {
    homepage?: Url[];

    [key: string]: any;

    constructor(data?: IIdentity) {
        super(data);
        this._discriminator = "Identity";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["homepage"])) {
                this.homepage = [] as any;
                for (let item of _data["homepage"])
                    this.homepage!.push(Url.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Identity {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "Account") {
            let result = new Account();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookAccount") {
            let result = new FacebookAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookPage") {
            let result = new FacebookPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GoogleAccount") {
            let result = new GoogleAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GooglePlace") {
            let result = new GooglePlace();
            result.init(data);
            return result;
        }
        if (data["_type"] === "InstagramAccount") {
            let result = new InstagramAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LegalIdentity") {
            let result = new LegalIdentity();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInAccount") {
            let result = new LinkedInAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInPage") {
            let result = new LinkedInPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Organization") {
            let result = new Organization();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Person") {
            let result = new Person();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TiktokAccount") {
            let result = new TiktokAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TwitterAccount") {
            let result = new TwitterAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "YouTubeAccount") {
            let result = new YouTubeAccount();
            result.init(data);
            return result;
        }
        let result = new Identity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.homepage)) {
            data["homepage"] = [];
            for (let item of this.homepage)
                data["homepage"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IIdentity extends IVertex {
    homepage?: Url[];

    [key: string]: any;
}

/** An (online) account, e.g. on a social media platform. */
export class Account extends Identity implements IAccount {
    accountId?: AccountId[];
    userName?: UserName[];
    screenName?: ScreenName[];
    firstActivity?: DateTimestamp[];
    lastActivity?: DateTimestamp[];
    /** Use HasAvatar edges instead. */
    avatar?: Content[];
    bio?: Description[];
    /** Connections count, indicating the number of bi-directional connections of this account. So connections where A follows B and B follows A, where A is this account. It is not the sum of followerCount anf followingCount. */
    connectionCount?: CounterValue[];
    /** Followers count, indicating the number of uni-directional connections where this account is the destination vertex. So a connection where B follows A, but A does not follow B, where A is this account */
    followerCount?: CounterValue[];
    /** Following count, indicating the number of uni-directional connections where this account is the starting vertex. So a connection where A follows B, but B does not follow A, where A is this account */
    followingCount?: CounterValue[];
    /** Comment count, indicating the number of comments published by this account. */
    commentCount?: CounterValue[];
    /** Post count, indicating the number of posts published by this account. */
    postCount?: CounterValue[];
    /** Album count, indicating the number of albums created by this account. */
    albumCount?: CounterValue[];
    status?: AccountStatus[];
    visibility?: AccountVisibility[];

    [key: string]: any;

    constructor(data?: IAccount) {
        super(data);
        this._discriminator = "Account";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["accountId"])) {
                this.accountId = [] as any;
                for (let item of _data["accountId"])
                    this.accountId!.push(AccountId.fromJS(item));
            }
            if (Array.isArray(_data["userName"])) {
                this.userName = [] as any;
                for (let item of _data["userName"])
                    this.userName!.push(UserName.fromJS(item));
            }
            if (Array.isArray(_data["screenName"])) {
                this.screenName = [] as any;
                for (let item of _data["screenName"])
                    this.screenName!.push(ScreenName.fromJS(item));
            }
            if (Array.isArray(_data["firstActivity"])) {
                this.firstActivity = [] as any;
                for (let item of _data["firstActivity"])
                    this.firstActivity!.push(DateTimestamp.fromJS(item));
            }
            if (Array.isArray(_data["lastActivity"])) {
                this.lastActivity = [] as any;
                for (let item of _data["lastActivity"])
                    this.lastActivity!.push(DateTimestamp.fromJS(item));
            }
            if (Array.isArray(_data["avatar"])) {
                this.avatar = [] as any;
                for (let item of _data["avatar"])
                    this.avatar!.push(Content.fromJS(item));
            }
            if (Array.isArray(_data["bio"])) {
                this.bio = [] as any;
                for (let item of _data["bio"])
                    this.bio!.push(Description.fromJS(item));
            }
            if (Array.isArray(_data["connectionCount"])) {
                this.connectionCount = [] as any;
                for (let item of _data["connectionCount"])
                    this.connectionCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["followerCount"])) {
                this.followerCount = [] as any;
                for (let item of _data["followerCount"])
                    this.followerCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["followingCount"])) {
                this.followingCount = [] as any;
                for (let item of _data["followingCount"])
                    this.followingCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["commentCount"])) {
                this.commentCount = [] as any;
                for (let item of _data["commentCount"])
                    this.commentCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["postCount"])) {
                this.postCount = [] as any;
                for (let item of _data["postCount"])
                    this.postCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["albumCount"])) {
                this.albumCount = [] as any;
                for (let item of _data["albumCount"])
                    this.albumCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["status"])) {
                this.status = [] as any;
                for (let item of _data["status"])
                    this.status!.push(AccountStatus.fromJS(item));
            }
            if (Array.isArray(_data["visibility"])) {
                this.visibility = [] as any;
                for (let item of _data["visibility"])
                    this.visibility!.push(AccountVisibility.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "FacebookAccount") {
            let result = new FacebookAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FacebookPage") {
            let result = new FacebookPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GoogleAccount") {
            let result = new GoogleAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "GooglePlace") {
            let result = new GooglePlace();
            result.init(data);
            return result;
        }
        if (data["_type"] === "InstagramAccount") {
            let result = new InstagramAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInAccount") {
            let result = new LinkedInAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LinkedInPage") {
            let result = new LinkedInPage();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TiktokAccount") {
            let result = new TiktokAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "TwitterAccount") {
            let result = new TwitterAccount();
            result.init(data);
            return result;
        }
        if (data["_type"] === "YouTubeAccount") {
            let result = new YouTubeAccount();
            result.init(data);
            return result;
        }
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.accountId)) {
            data["accountId"] = [];
            for (let item of this.accountId)
                data["accountId"].push(item.toJSON());
        }
        if (Array.isArray(this.userName)) {
            data["userName"] = [];
            for (let item of this.userName)
                data["userName"].push(item.toJSON());
        }
        if (Array.isArray(this.screenName)) {
            data["screenName"] = [];
            for (let item of this.screenName)
                data["screenName"].push(item.toJSON());
        }
        if (Array.isArray(this.firstActivity)) {
            data["firstActivity"] = [];
            for (let item of this.firstActivity)
                data["firstActivity"].push(item.toJSON());
        }
        if (Array.isArray(this.lastActivity)) {
            data["lastActivity"] = [];
            for (let item of this.lastActivity)
                data["lastActivity"].push(item.toJSON());
        }
        if (Array.isArray(this.avatar)) {
            data["avatar"] = [];
            for (let item of this.avatar)
                data["avatar"].push(item.toJSON());
        }
        if (Array.isArray(this.bio)) {
            data["bio"] = [];
            for (let item of this.bio)
                data["bio"].push(item.toJSON());
        }
        if (Array.isArray(this.connectionCount)) {
            data["connectionCount"] = [];
            for (let item of this.connectionCount)
                data["connectionCount"].push(item.toJSON());
        }
        if (Array.isArray(this.followerCount)) {
            data["followerCount"] = [];
            for (let item of this.followerCount)
                data["followerCount"].push(item.toJSON());
        }
        if (Array.isArray(this.followingCount)) {
            data["followingCount"] = [];
            for (let item of this.followingCount)
                data["followingCount"].push(item.toJSON());
        }
        if (Array.isArray(this.commentCount)) {
            data["commentCount"] = [];
            for (let item of this.commentCount)
                data["commentCount"].push(item.toJSON());
        }
        if (Array.isArray(this.postCount)) {
            data["postCount"] = [];
            for (let item of this.postCount)
                data["postCount"].push(item.toJSON());
        }
        if (Array.isArray(this.albumCount)) {
            data["albumCount"] = [];
            for (let item of this.albumCount)
                data["albumCount"].push(item.toJSON());
        }
        if (Array.isArray(this.status)) {
            data["status"] = [];
            for (let item of this.status)
                data["status"].push(item.toJSON());
        }
        if (Array.isArray(this.visibility)) {
            data["visibility"] = [];
            for (let item of this.visibility)
                data["visibility"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An (online) account, e.g. on a social media platform. */
export interface IAccount extends IIdentity {
    accountId?: AccountId[];
    userName?: UserName[];
    screenName?: ScreenName[];
    firstActivity?: DateTimestamp[];
    lastActivity?: DateTimestamp[];
    /** Use HasAvatar edges instead. */
    avatar?: Content[];
    bio?: Description[];
    /** Connections count, indicating the number of bi-directional connections of this account. So connections where A follows B and B follows A, where A is this account. It is not the sum of followerCount anf followingCount. */
    connectionCount?: CounterValue[];
    /** Followers count, indicating the number of uni-directional connections where this account is the destination vertex. So a connection where B follows A, but A does not follow B, where A is this account */
    followerCount?: CounterValue[];
    /** Following count, indicating the number of uni-directional connections where this account is the starting vertex. So a connection where A follows B, but B does not follow A, where A is this account */
    followingCount?: CounterValue[];
    /** Comment count, indicating the number of comments published by this account. */
    commentCount?: CounterValue[];
    /** Post count, indicating the number of posts published by this account. */
    postCount?: CounterValue[];
    /** Album count, indicating the number of albums created by this account. */
    albumCount?: CounterValue[];
    status?: AccountStatus[];
    visibility?: AccountVisibility[];

    [key: string]: any;
}

/** A system oriented account identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export class AccountId implements IAccountId {
    value!: string;

    [key: string]: any;

    constructor(data?: IAccountId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AccountId {
        data = typeof data === 'object' ? data : {};
        let result = new AccountId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A system oriented account identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export interface IAccountId {
    value: string;

    [key: string]: any;
}

/** A (directed) edge associating two vertices with a particular label (the _type of the edge). */
export class Edge implements IEdge {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    start!: string;
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    destination!: string;

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: IEdge) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Edge";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.start = _data["start"];
            this.destination = _data["destination"];
        }
    }

    static fromJS(data: any): Edge {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "AccountOn") {
            let result = new AccountOn();
            result.init(data);
            return result;
        }
        if (data["_type"] === "AssociatedWith") {
            let result = new AssociatedWith();
            result.init(data);
            return result;
        }
        if (data["_type"] === "CheckIn") {
            let result = new CheckIn();
            result.init(data);
            return result;
        }
        if (data["_type"] === "CommentOn") {
            let result = new CommentOn();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Depicts") {
            let result = new Depicts();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Employee") {
            let result = new Employee();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Employer") {
            let result = new Employer();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Enriches") {
            let result = new Enriches();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Follows") {
            let result = new Follows();
            result.init(data);
            return result;
        }
        if (data["_type"] === "FriendOf") {
            let result = new FriendOf();
            result.init(data);
            return result;
        }
        if (data["_type"] === "HasAvatar") {
            let result = new HasAvatar();
            result.init(data);
            return result;
        }
        if (data["_type"] === "HasEducation") {
            let result = new HasEducation();
            result.init(data);
            return result;
        }
        if (data["_type"] === "HasEmailAddress") {
            let result = new HasEmailAddress();
            result.init(data);
            return result;
        }
        if (data["_type"] === "HasPhoneNumber") {
            let result = new HasPhoneNumber();
            result.init(data);
            return result;
        }
        if (data["_type"] === "HostedBy") {
            let result = new HostedBy();
            result.init(data);
            return result;
        }
        if (data["_type"] === "IdentifiedAs") {
            let result = new IdentifiedAs();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Indicates") {
            let result = new Indicates();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Likes") {
            let result = new Likes();
            result.init(data);
            return result;
        }
        if (data["_type"] === "ListsEducation") {
            let result = new ListsEducation();
            result.init(data);
            return result;
        }
        if (data["_type"] === "ListsEmployment") {
            let result = new ListsEmployment();
            result.init(data);
            return result;
        }
        if (data["_type"] === "LocatedAt") {
            let result = new LocatedAt();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Mentions") {
            let result = new Mentions();
            result.init(data);
            return result;
        }
        if (data["_type"] === "PostedOn") {
            let result = new PostedOn();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Published") {
            let result = new Published();
            result.init(data);
            return result;
        }
        if (data["_type"] === "ReplyTo") {
            let result = new ReplyTo();
            result.init(data);
            return result;
        }
        if (data["_type"] === "ReviewedIn") {
            let result = new ReviewedIn();
            result.init(data);
            return result;
        }
        if (data["_type"] === "SameAs") {
            let result = new SameAs();
            result.init(data);
            return result;
        }
        if (data["_type"] === "StudyProgramAt") {
            let result = new StudyProgramAt();
            result.init(data);
            return result;
        }
        let result = new Edge();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._discriminator;
        data["start"] = this.start;
        data["destination"] = this.destination;
        return data;
    }
}

/** A (directed) edge associating two vertices with a particular label (the _type of the edge). */
export interface IEdge {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    start: string;
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    destination: string;

    [key: string]: any;
}

/** Indicates that an Account is active in a particular environment (e.g. facebook), e.g. because it is registered there, or can publish content, etc. Typically this would be a website. */
export class AccountOn extends Edge implements IAccountOn {

    [key: string]: any;

    constructor(data?: IAccountOn) {
        super(data);
        this._discriminator = "AccountOn";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AccountOn {
        data = typeof data === 'object' ? data : {};
        let result = new AccountOn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an Account is active in a particular environment (e.g. facebook), e.g. because it is registered there, or can publish content, etc. Typically this would be a website. */
export interface IAccountOn extends IEdge {

    [key: string]: any;
}

export class AccountStatus implements IAccountStatus {
    value?: AccountStatusValue;

    [key: string]: any;

    constructor(data?: IAccountStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AccountStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AccountStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IAccountStatus {
    value?: AccountStatusValue;

    [key: string]: any;
}

export class AccountVisibility implements IAccountVisibility {
    value?: AccountVisibilityValue;

    [key: string]: any;

    constructor(data?: IAccountVisibility) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AccountVisibility {
        data = typeof data === 'object' ? data : {};
        let result = new AccountVisibility();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IAccountVisibility {
    value?: AccountVisibilityValue;

    [key: string]: any;
}

/** An address as either an (opaque) address string or as an annotated address; that is, a list of strings, each annotated with its role in the address (e.g. street, locality or country). */
export class Address implements IAddress {

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: IAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Address";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Address {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "AddressString") {
            let result = new AddressString();
            result.init(data);
            return result;
        }
        if (data["_type"] === "AnnotatedAddress") {
            let result = new AnnotatedAddress();
            result.init(data);
            return result;
        }
        let result = new Address();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._discriminator;
        return data;
    }
}

/** An address as either an (opaque) address string or as an annotated address; that is, a list of strings, each annotated with its role in the address (e.g. street, locality or country). */
export interface IAddress {

    [key: string]: any;
}

/** An element in an AnnotatedAddress: a string labeled with a specific 'role', e.g. STREET_NAME. */
export class AddressElement implements IAddressElement {
    /** The various roles for elements in an AnnotatedAddress. */
    role?: AddressElementRole;
    value?: string;

    [key: string]: any;

    constructor(data?: IAddressElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AddressElement {
        data = typeof data === 'object' ? data : {};
        let result = new AddressElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role;
        data["value"] = this.value;
        return data;
    }
}

/** An element in an AnnotatedAddress: a string labeled with a specific 'role', e.g. STREET_NAME. */
export interface IAddressElement {
    /** The various roles for elements in an AnnotatedAddress. */
    role?: AddressElementRole;
    value?: string;

    [key: string]: any;
}

/** An address string of which the elements (tokens) aren't annotated. Use an AnnotatedAddress when more information is available, e.g. a separate street address, postal code and locality. */
export class AddressString extends Address implements IAddressString {
    value?: string;

    [key: string]: any;

    constructor(data?: IAddressString) {
        super(data);
        this._discriminator = "AddressString";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AddressString {
        data = typeof data === 'object' ? data : {};
        let result = new AddressString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** An address string of which the elements (tokens) aren't annotated. Use an AnnotatedAddress when more information is available, e.g. a separate street address, postal code and locality. */
export interface IAddressString extends IAddress {
    value?: string;

    [key: string]: any;
}

/** The annotated address components that compose an address, e.g. street, house number, etc. By extending AddressElementRole this class can support any address that can be written as a sequence of address elements. E.g.  supporting Japanese addresses would entail adding roles such as prefecture, districts, blocks, etc. */
export class AnnotatedAddress extends Address implements IAnnotatedAddress {
    value?: AddressElement[];

    [key: string]: any;

    constructor(data?: IAnnotatedAddress) {
        super(data);
        this._discriminator = "AnnotatedAddress";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(AddressElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnnotatedAddress {
        data = typeof data === 'object' ? data : {};
        let result = new AnnotatedAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** The annotated address components that compose an address, e.g. street, house number, etc. By extending AddressElementRole this class can support any address that can be written as a sequence of address elements. E.g.  supporting Japanese addresses would entail adding roles such as prefecture, districts, blocks, etc. */
export interface IAnnotatedAddress extends IAddress {
    value?: AddressElement[];

    [key: string]: any;
}

/** A name of a person, either a person name string, or an annotated name in case more details on the name structure are available (e.g. given name(s), family name, etc.) */
export class PersonName implements IPersonName {

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: IPersonName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "PersonName";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): PersonName {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "AnnotatedPersonName") {
            let result = new AnnotatedPersonName();
            result.init(data);
            return result;
        }
        if (data["_type"] === "PersonNameString") {
            let result = new PersonNameString();
            result.init(data);
            return result;
        }
        let result = new PersonName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._discriminator;
        return data;
    }
}

/** A name of a person, either a person name string, or an annotated name in case more details on the name structure are available (e.g. given name(s), family name, etc.) */
export interface IPersonName {

    [key: string]: any;
}

/** A name of a person that is expressed as a sequence of PersonNameElements that correspond to parts of the name with a PersonNameElementRole annotation. E.g. 'John O Doe': John (given name) O (initial) Doe (family name). */
export class AnnotatedPersonName extends PersonName implements IAnnotatedPersonName {
    value?: PersonNameElement[];

    [key: string]: any;

    constructor(data?: IAnnotatedPersonName) {
        super(data);
        this._discriminator = "AnnotatedPersonName";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["value"])) {
                this.value = [] as any;
                for (let item of _data["value"])
                    this.value!.push(PersonNameElement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AnnotatedPersonName {
        data = typeof data === 'object' ? data : {};
        let result = new AnnotatedPersonName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.value)) {
            data["value"] = [];
            for (let item of this.value)
                data["value"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A name of a person that is expressed as a sequence of PersonNameElements that correspond to parts of the name with a PersonNameElementRole annotation. E.g. 'John O Doe': John (given name) O (initial) Doe (family name). */
export interface IAnnotatedPersonName extends IPersonName {
    value?: PersonNameElement[];

    [key: string]: any;
}

/** Indicates that the Vertex is associated with a certain RiskIndicator. */
export class AssociatedWith extends Edge implements IAssociatedWith {

    [key: string]: any;

    constructor(data?: IAssociatedWith) {
        super(data);
        this._discriminator = "AssociatedWith";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): AssociatedWith {
        data = typeof data === 'object' ? data : {};
        let result = new AssociatedWith();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that the Vertex is associated with a certain RiskIndicator. */
export interface IAssociatedWith extends IEdge {

    [key: string]: any;
}

/** An average rating found in a Google Place. */
export class AverageRating implements IAverageRating {
    value?: AverageRatingValue;

    [key: string]: any;

    constructor(data?: IAverageRating) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? AverageRatingValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AverageRating {
        data = typeof data === 'object' ? data : {};
        let result = new AverageRating();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** An average rating found in a Google Place. */
export interface IAverageRating {
    value?: AverageRatingValue;

    [key: string]: any;
}

/** Rating value, including the minimum and maximum value a rating can be (e.g. on Google Places,you are bound by a minimum of 1 star and a maximum of 5) */
export class RatingValue implements IRatingValue {
    rating!: number;
    ratingScaleMin!: number;
    ratingScaleMax!: number;

    [key: string]: any;

    constructor(data?: IRatingValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.rating = _data["rating"];
            this.ratingScaleMin = _data["ratingScaleMin"];
            this.ratingScaleMax = _data["ratingScaleMax"];
        }
    }

    static fromJS(data: any): RatingValue {
        data = typeof data === 'object' ? data : {};
        let result = new RatingValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["rating"] = this.rating;
        data["ratingScaleMin"] = this.ratingScaleMin;
        data["ratingScaleMax"] = this.ratingScaleMax;
        return data;
    }
}

/** Rating value, including the minimum and maximum value a rating can be (e.g. on Google Places,you are bound by a minimum of 1 star and a maximum of 5) */
export interface IRatingValue {
    rating: number;
    ratingScaleMin: number;
    ratingScaleMax: number;

    [key: string]: any;
}

/** A rating value that gives the average over a number of ratings. Amount references to the number of ratings this is the average of. */
export class AverageRatingValue extends RatingValue implements IAverageRatingValue {
    numRatings?: number;

    [key: string]: any;

    constructor(data?: IAverageRatingValue) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.numRatings = _data["numRatings"];
        }
    }

    static fromJS(data: any): AverageRatingValue {
        data = typeof data === 'object' ? data : {};
        let result = new AverageRatingValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["numRatings"] = this.numRatings;
        super.toJSON(data);
        return data;
    }
}

/** A rating value that gives the average over a number of ratings. Amount references to the number of ratings this is the average of. */
export interface IAverageRatingValue extends IRatingValue {
    numRatings?: number;

    [key: string]: any;
}

export class BusinessStatus implements IBusinessStatus {
    value?: BusinessStatusValue;

    [key: string]: any;

    constructor(data?: IBusinessStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? BusinessStatusValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BusinessStatus {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IBusinessStatus {
    value?: BusinessStatusValue;

    [key: string]: any;
}

export class BusinessStatusValue implements IBusinessStatusValue {
    businessStatusType!: BusinessStatusValueBusinessStatusType;

    [key: string]: any;

    constructor(data?: IBusinessStatusValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.businessStatusType = _data["businessStatusType"];
        }
    }

    static fromJS(data: any): BusinessStatusValue {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessStatusValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["businessStatusType"] = this.businessStatusType;
        return data;
    }
}

export interface IBusinessStatusValue {
    businessStatusType: BusinessStatusValueBusinessStatusType;

    [key: string]: any;
}

export class Caption implements ICaption {
    value!: string;

    [key: string]: any;

    constructor(data?: ICaption) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Caption {
        data = typeof data === 'object' ? data : {};
        let result = new Caption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface ICaption {
    value: string;

    [key: string]: any;
}

/** Indicates that an Account checked in on another vertex, e.g. an account or location. */
export class CheckIn extends Edge implements ICheckIn {
    visitedOn?: DateTimestamp[];

    [key: string]: any;

    constructor(data?: ICheckIn) {
        super(data);
        this._discriminator = "CheckIn";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["visitedOn"])) {
                this.visitedOn = [] as any;
                for (let item of _data["visitedOn"])
                    this.visitedOn!.push(DateTimestamp.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CheckIn {
        data = typeof data === 'object' ? data : {};
        let result = new CheckIn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.visitedOn)) {
            data["visitedOn"] = [];
            for (let item of this.visitedOn)
                data["visitedOn"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an Account checked in on another vertex, e.g. an account or location. */
export interface ICheckIn extends IEdge {
    visitedOn?: DateTimestamp[];

    [key: string]: any;
}

export class Resource extends Vertex implements IResource {
    resourceDescription?: Description[];
    url?: Url[];
    createdAt?: DateTimestamp[];
    mediaType?: MediaType[];
    classification?: ResourceClassification[];
    title?: Title[];
    caption?: Caption[];
    representation?: Content[];

    [key: string]: any;

    constructor(data?: IResource) {
        super(data);
        this._discriminator = "Resource";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["resourceDescription"])) {
                this.resourceDescription = [] as any;
                for (let item of _data["resourceDescription"])
                    this.resourceDescription!.push(Description.fromJS(item));
            }
            if (Array.isArray(_data["url"])) {
                this.url = [] as any;
                for (let item of _data["url"])
                    this.url!.push(Url.fromJS(item));
            }
            if (Array.isArray(_data["createdAt"])) {
                this.createdAt = [] as any;
                for (let item of _data["createdAt"])
                    this.createdAt!.push(DateTimestamp.fromJS(item));
            }
            if (Array.isArray(_data["mediaType"])) {
                this.mediaType = [] as any;
                for (let item of _data["mediaType"])
                    this.mediaType!.push(MediaType.fromJS(item));
            }
            if (Array.isArray(_data["classification"])) {
                this.classification = [] as any;
                for (let item of _data["classification"])
                    this.classification!.push(ResourceClassification.fromJS(item));
            }
            if (Array.isArray(_data["title"])) {
                this.title = [] as any;
                for (let item of _data["title"])
                    this.title!.push(Title.fromJS(item));
            }
            if (Array.isArray(_data["caption"])) {
                this.caption = [] as any;
                for (let item of _data["caption"])
                    this.caption!.push(Caption.fromJS(item));
            }
            if (Array.isArray(_data["representation"])) {
                this.representation = [] as any;
                for (let item of _data["representation"])
                    this.representation!.push(Content.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Resource {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "Comment") {
            let result = new Comment();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Review") {
            let result = new Review();
            result.init(data);
            return result;
        }
        let result = new Resource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.resourceDescription)) {
            data["resourceDescription"] = [];
            for (let item of this.resourceDescription)
                data["resourceDescription"].push(item.toJSON());
        }
        if (Array.isArray(this.url)) {
            data["url"] = [];
            for (let item of this.url)
                data["url"].push(item.toJSON());
        }
        if (Array.isArray(this.createdAt)) {
            data["createdAt"] = [];
            for (let item of this.createdAt)
                data["createdAt"].push(item.toJSON());
        }
        if (Array.isArray(this.mediaType)) {
            data["mediaType"] = [];
            for (let item of this.mediaType)
                data["mediaType"].push(item.toJSON());
        }
        if (Array.isArray(this.classification)) {
            data["classification"] = [];
            for (let item of this.classification)
                data["classification"].push(item.toJSON());
        }
        if (Array.isArray(this.title)) {
            data["title"] = [];
            for (let item of this.title)
                data["title"].push(item.toJSON());
        }
        if (Array.isArray(this.caption)) {
            data["caption"] = [];
            for (let item of this.caption)
                data["caption"].push(item.toJSON());
        }
        if (Array.isArray(this.representation)) {
            data["representation"] = [];
            for (let item of this.representation)
                data["representation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResource extends IVertex {
    resourceDescription?: Description[];
    url?: Url[];
    createdAt?: DateTimestamp[];
    mediaType?: MediaType[];
    classification?: ResourceClassification[];
    title?: Title[];
    caption?: Caption[];
    representation?: Content[];

    [key: string]: any;
}

/** A comment on a resource. */
export class Comment extends Resource implements IComment {

    [key: string]: any;

    constructor(data?: IComment) {
        super(data);
        this._discriminator = "Comment";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** A comment on a resource. */
export interface IComment extends IResource {

    [key: string]: any;
}

export class CommentOn extends Edge implements ICommentOn {

    [key: string]: any;

    constructor(data?: ICommentOn) {
        super(data);
        this._discriminator = "CommentOn";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): CommentOn {
        data = typeof data === 'object' ? data : {};
        let result = new CommentOn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICommentOn extends IEdge {

    [key: string]: any;
}

/** The 'scope' of a connect investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export class ConnectScope implements IConnectScope {
    graph!: Graph;
    /** Pairs of subjects to investigation whether connections between them can be found through open source intelligence. */
    subjects!: VertexPair[];
    /** Whether to investigate connections found on the web in general. */
    web?: boolean;
    /** Whether to investigate connections on facebook. */
    facebook?: boolean;
    /** Whether to investigate connections on twitter. */
    twitter?: boolean;
    /** Whether to investigate connections on linkedin. */
    linkedin?: boolean;
    /** Whether to investigate connections on instagram. */
    instagram?: boolean;

    [key: string]: any;

    constructor(data?: IConnectScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subjects = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(VertexPair.fromJS(item));
            }
            this.web = _data["web"];
            this.facebook = _data["facebook"];
            this.twitter = _data["twitter"];
            this.linkedin = _data["linkedin"];
            this.instagram = _data["instagram"];
        }
    }

    static fromJS(data: any): ConnectScope {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        data["web"] = this.web;
        data["facebook"] = this.facebook;
        data["twitter"] = this.twitter;
        data["linkedin"] = this.linkedin;
        data["instagram"] = this.instagram;
        return data;
    }
}

/** The 'scope' of a connect investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export interface IConnectScope {
    graph: Graph;
    /** Pairs of subjects to investigation whether connections between them can be found through open source intelligence. */
    subjects: VertexPair[];
    /** Whether to investigate connections found on the web in general. */
    web?: boolean;
    /** Whether to investigate connections on facebook. */
    facebook?: boolean;
    /** Whether to investigate connections on twitter. */
    twitter?: boolean;
    /** Whether to investigate connections on linkedin. */
    linkedin?: boolean;
    /** Whether to investigate connections on instagram. */
    instagram?: boolean;

    [key: string]: any;
}

/** Content of a resource, profile picture, etc. represented by a base64 encoded string. */
export class Content implements IContent {
    value?: ContentValue;

    [key: string]: any;

    constructor(data?: IContent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? ContentValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Content {
        data = typeof data === 'object' ? data : {};
        let result = new Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Content of a resource, profile picture, etc. represented by a base64 encoded string. */
export interface IContent {
    value?: ContentValue;

    [key: string]: any;
}

/** Content as a base64 encoded string (bytes) with meta data: md5,  and (optionally) content type. Or content as a string (text) with content type 'text' */
export class ContentValue implements IContentValue {
    bytes?: string;
    text?: string;
    md5?: string;
    contentType?: string | undefined;

    [key: string]: any;

    constructor(data?: IContentValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.bytes = _data["bytes"];
            this.text = _data["text"];
            this.md5 = _data["md5"];
            this.contentType = _data["contentType"];
        }
    }

    static fromJS(data: any): ContentValue {
        data = typeof data === 'object' ? data : {};
        let result = new ContentValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["bytes"] = this.bytes;
        data["text"] = this.text;
        data["md5"] = this.md5;
        data["contentType"] = this.contentType;
        return data;
    }
}

/** Content as a base64 encoded string (bytes) with meta data: md5,  and (optionally) content type. Or content as a string (text) with content type 'text' */
export interface IContentValue {
    bytes?: string;
    text?: string;
    md5?: string;
    contentType?: string | undefined;

    [key: string]: any;
}

/** A counter for objects related to a vertex, for example the number of photos in an album or the number of followers of an account. */
export class CounterValue implements ICounterValue {
    value!: number;

    [key: string]: any;

    constructor(data?: ICounterValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CounterValue {
        data = typeof data === 'object' ? data : {};
        let result = new CounterValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A counter for objects related to a vertex, for example the number of photos in an album or the number of followers of an account. */
export interface ICounterValue {
    value: number;

    [key: string]: any;
}

/** A country as either a country code (2 uppercase characters) or as country name. */
export class Country implements ICountry {

    [key: string]: any;

    protected _discriminator: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Country";
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "CountryCode") {
            let result = new CountryCode();
            result.init(data);
            return result;
        }
        if (data["_type"] === "CountryName") {
            let result = new CountryName();
            result.init(data);
            return result;
        }
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["_type"] = this._discriminator;
        return data;
    }
}

/** A country as either a country code (2 uppercase characters) or as country name. */
export interface ICountry {

    [key: string]: any;
}

/** Country code in all uppercase as defined in ISO 3166-1 alpha-2 */
export class CountryCode extends Country implements ICountryCode {
    value?: string;

    [key: string]: any;

    constructor(data?: ICountryCode) {
        super(data);
        this._discriminator = "CountryCode";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CountryCode {
        data = typeof data === 'object' ? data : {};
        let result = new CountryCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** Country code in all uppercase as defined in ISO 3166-1 alpha-2 */
export interface ICountryCode extends ICountry {
    value?: string;

    [key: string]: any;
}

/** Full country name */
export class CountryName extends Country implements ICountryName {
    value?: string;

    [key: string]: any;

    constructor(data?: ICountryName) {
        super(data);
        this._discriminator = "CountryName";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): CountryName {
        data = typeof data === 'object' ? data : {};
        let result = new CountryName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** Full country name */
export interface ICountryName extends ICountry {
    value?: string;

    [key: string]: any;
}

/** A (local) date value, e.g. 2017-07-21. */
export class DateDto implements IDateDto {
    value?: string;

    [key: string]: any;

    constructor(data?: IDateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DateDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A (local) date value, e.g. 2017-07-21. */
export interface IDateDto {
    value?: string;

    [key: string]: any;
}

/** With value in ISO 8601 time format */
export class DateTimestamp implements IDateTimestamp {
    value?: string;

    [key: string]: any;

    constructor(data?: IDateTimestamp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): DateTimestamp {
        data = typeof data === 'object' ? data : {};
        let result = new DateTimestamp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** With value in ISO 8601 time format */
export interface IDateTimestamp {
    value?: string;

    [key: string]: any;
}

export class Degree implements IDegree {
    value!: string;

    [key: string]: any;

    constructor(data?: IDegree) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Degree {
        data = typeof data === 'object' ? data : {};
        let result = new Degree();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IDegree {
    value: string;

    [key: string]: any;
}

/** Indicates that something is depicted in a resource, e.g. a location is shown in an image. */
export class Depicts extends Edge implements IDepicts {

    [key: string]: any;

    constructor(data?: IDepicts) {
        super(data);
        this._discriminator = "Depicts";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Depicts {
        data = typeof data === 'object' ? data : {};
        let result = new Depicts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that something is depicted in a resource, e.g. a location is shown in an image. */
export interface IDepicts extends IEdge {

    [key: string]: any;
}

export class Description implements IDescription {
    value!: string;

    [key: string]: any;

    constructor(data?: IDescription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Description {
        data = typeof data === 'object' ? data : {};
        let result = new Description();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IDescription {
    value: string;

    [key: string]: any;
}

/** Information on a person's driver license. */
export class DriverLicense implements IDriverLicense {
    value?: DriverLicenseValue;

    [key: string]: any;

    constructor(data?: IDriverLicense) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? DriverLicenseValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): DriverLicense {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicense();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Information on a person's driver license. */
export interface IDriverLicense {
    value?: DriverLicenseValue;

    [key: string]: any;
}

export class DriverLicenseValue implements IDriverLicenseValue {
    documentId?: string;

    [key: string]: any;

    constructor(data?: IDriverLicenseValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): DriverLicenseValue {
        data = typeof data === 'object' ? data : {};
        let result = new DriverLicenseValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["documentId"] = this.documentId;
        return data;
    }
}

export interface IDriverLicenseValue {
    documentId?: string;

    [key: string]: any;
}

/** An education at an organization */
export class Education extends Vertex implements IEducation {
    educationInterval?: Interval[];
    degree?: Degree[];
    educationDescription?: Description[];

    [key: string]: any;

    constructor(data?: IEducation) {
        super(data);
        this._discriminator = "Education";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["educationInterval"])) {
                this.educationInterval = [] as any;
                for (let item of _data["educationInterval"])
                    this.educationInterval!.push(Interval.fromJS(item));
            }
            if (Array.isArray(_data["degree"])) {
                this.degree = [] as any;
                for (let item of _data["degree"])
                    this.degree!.push(Degree.fromJS(item));
            }
            if (Array.isArray(_data["educationDescription"])) {
                this.educationDescription = [] as any;
                for (let item of _data["educationDescription"])
                    this.educationDescription!.push(Description.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Education {
        data = typeof data === 'object' ? data : {};
        let result = new Education();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.educationInterval)) {
            data["educationInterval"] = [];
            for (let item of this.educationInterval)
                data["educationInterval"].push(item.toJSON());
        }
        if (Array.isArray(this.degree)) {
            data["degree"] = [];
            for (let item of this.degree)
                data["degree"].push(item.toJSON());
        }
        if (Array.isArray(this.educationDescription)) {
            data["educationDescription"] = [];
            for (let item of this.educationDescription)
                data["educationDescription"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An education at an organization */
export interface IEducation extends IVertex {
    educationInterval?: Interval[];
    degree?: Degree[];
    educationDescription?: Description[];

    [key: string]: any;
}

export class EmailAddress extends Vertex implements IEmailAddress {
    email?: EmailAddressString[];

    [key: string]: any;

    constructor(data?: IEmailAddress) {
        super(data);
        this._discriminator = "EmailAddress";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["email"])) {
                this.email = [] as any;
                for (let item of _data["email"])
                    this.email!.push(EmailAddressString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.email)) {
            data["email"] = [];
            for (let item of this.email)
                data["email"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEmailAddress extends IVertex {
    email?: EmailAddressString[];

    [key: string]: any;
}

export class EmailAddressString implements IEmailAddressString {
    value!: string;

    [key: string]: any;

    constructor(data?: IEmailAddressString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EmailAddressString {
        data = typeof data === 'object' ? data : {};
        let result = new EmailAddressString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IEmailAddressString {
    value: string;

    [key: string]: any;
}

/** Indicates that a person is employed as employment */
export class Employee extends Edge implements IEmployee {

    [key: string]: any;

    constructor(data?: IEmployee) {
        super(data);
        this._discriminator = "Employee";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a person is employed as employment */
export interface IEmployee extends IEdge {

    [key: string]: any;
}

/** Indicates that an organization is employer of a employment */
export class Employer extends Edge implements IEmployer {

    [key: string]: any;

    constructor(data?: IEmployer) {
        super(data);
        this._discriminator = "Employer";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Employer {
        data = typeof data === 'object' ? data : {};
        let result = new Employer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an organization is employer of a employment */
export interface IEmployer extends IEdge {

    [key: string]: any;
}

export class Employment extends Vertex implements IEmployment {
    interval?: Interval[];
    jobDescription?: Description[];
    position?: Position[];
    employmentClassification?: EmploymentClassification[];

    [key: string]: any;

    constructor(data?: IEmployment) {
        super(data);
        this._discriminator = "Employment";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["interval"])) {
                this.interval = [] as any;
                for (let item of _data["interval"])
                    this.interval!.push(Interval.fromJS(item));
            }
            if (Array.isArray(_data["jobDescription"])) {
                this.jobDescription = [] as any;
                for (let item of _data["jobDescription"])
                    this.jobDescription!.push(Description.fromJS(item));
            }
            if (Array.isArray(_data["position"])) {
                this.position = [] as any;
                for (let item of _data["position"])
                    this.position!.push(Position.fromJS(item));
            }
            if (Array.isArray(_data["employmentClassification"])) {
                this.employmentClassification = [] as any;
                for (let item of _data["employmentClassification"])
                    this.employmentClassification!.push(EmploymentClassification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Employment {
        data = typeof data === 'object' ? data : {};
        let result = new Employment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.interval)) {
            data["interval"] = [];
            for (let item of this.interval)
                data["interval"].push(item.toJSON());
        }
        if (Array.isArray(this.jobDescription)) {
            data["jobDescription"] = [];
            for (let item of this.jobDescription)
                data["jobDescription"].push(item.toJSON());
        }
        if (Array.isArray(this.position)) {
            data["position"] = [];
            for (let item of this.position)
                data["position"].push(item.toJSON());
        }
        if (Array.isArray(this.employmentClassification)) {
            data["employmentClassification"] = [];
            for (let item of this.employmentClassification)
                data["employmentClassification"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IEmployment extends IVertex {
    interval?: Interval[];
    jobDescription?: Description[];
    position?: Position[];
    employmentClassification?: EmploymentClassification[];

    [key: string]: any;
}

export class EmploymentClassification implements IEmploymentClassification {
    value?: EmploymentClassificationValue;

    [key: string]: any;

    constructor(data?: IEmploymentClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? EmploymentClassificationValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EmploymentClassification {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IEmploymentClassification {
    value?: EmploymentClassificationValue;

    [key: string]: any;
}

export class EmploymentClassificationValue implements IEmploymentClassificationValue {
    classificationType!: EmploymentClassificationValueClassificationType;

    [key: string]: any;

    constructor(data?: IEmploymentClassificationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.classificationType = _data["classificationType"];
        }
    }

    static fromJS(data: any): EmploymentClassificationValue {
        data = typeof data === 'object' ? data : {};
        let result = new EmploymentClassificationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["classificationType"] = this.classificationType;
        return data;
    }
}

export interface IEmploymentClassificationValue {
    classificationType: EmploymentClassificationValueClassificationType;

    [key: string]: any;
}

/** Indicates that a Resource enriches another Resource. Example: Image enriches Post */
export class Enriches extends Edge implements IEnriches {

    [key: string]: any;

    constructor(data?: IEnriches) {
        super(data);
        this._discriminator = "Enriches";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Enriches {
        data = typeof data === 'object' ? data : {};
        let result = new Enriches();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a Resource enriches another Resource. Example: Image enriches Post */
export interface IEnriches extends IEdge {

    [key: string]: any;
}

/** A system oriented event identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export class EventId implements IEventId {
    value!: string;

    [key: string]: any;

    constructor(data?: IEventId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EventId {
        data = typeof data === 'object' ? data : {};
        let result = new EventId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A system oriented event identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export interface IEventId {
    value: string;

    [key: string]: any;
}

export class EventType implements IEventType {
    value?: EventTypeValue;

    [key: string]: any;

    constructor(data?: IEventType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): EventType {
        data = typeof data === 'object' ? data : {};
        let result = new EventType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IEventType {
    value?: EventTypeValue;

    [key: string]: any;
}

/** An account on Facebook, accountId corresponds to https://www.facebook.com/profile.php?id={accountId}, userName corresponds to https://www.facebook.com/{userName}, screenName corresponds to the name of the account home page. */
export class FacebookAccount extends Account implements IFacebookAccount {
    dateOfBirth?: PartialDateTime[];
    gender?: Gender[];

    [key: string]: any;

    constructor(data?: IFacebookAccount) {
        super(data);
        this._discriminator = "FacebookAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["dateOfBirth"])) {
                this.dateOfBirth = [] as any;
                for (let item of _data["dateOfBirth"])
                    this.dateOfBirth!.push(PartialDateTime.fromJS(item));
            }
            if (Array.isArray(_data["gender"])) {
                this.gender = [] as any;
                for (let item of _data["gender"])
                    this.gender!.push(Gender.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacebookAccount {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.dateOfBirth)) {
            data["dateOfBirth"] = [];
            for (let item of this.dateOfBirth)
                data["dateOfBirth"].push(item.toJSON());
        }
        if (Array.isArray(this.gender)) {
            data["gender"] = [];
            for (let item of this.gender)
                data["gender"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An account on Facebook, accountId corresponds to https://www.facebook.com/profile.php?id={accountId}, userName corresponds to https://www.facebook.com/{userName}, screenName corresponds to the name of the account home page. */
export interface IFacebookAccount extends IAccount {
    dateOfBirth?: PartialDateTime[];
    gender?: Gender[];

    [key: string]: any;
}

/** An event on Facebook that is hosted by a profile, page or group. */
export class FacebookEvent extends Vertex implements IFacebookEvent {
    eventId?: EventId[];
    description?: Description[];
    goingCount?: CounterValue[];
    interestedCount?: CounterValue[];
    eventType?: EventType[];
    homepage?: Url[];
    title?: Title[];
    startDateTime?: DateTimestamp[];
    endDateTime?: DateTimestamp[];

    [key: string]: any;

    constructor(data?: IFacebookEvent) {
        super(data);
        this._discriminator = "FacebookEvent";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["eventId"])) {
                this.eventId = [] as any;
                for (let item of _data["eventId"])
                    this.eventId!.push(EventId.fromJS(item));
            }
            if (Array.isArray(_data["description"])) {
                this.description = [] as any;
                for (let item of _data["description"])
                    this.description!.push(Description.fromJS(item));
            }
            if (Array.isArray(_data["goingCount"])) {
                this.goingCount = [] as any;
                for (let item of _data["goingCount"])
                    this.goingCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["interestedCount"])) {
                this.interestedCount = [] as any;
                for (let item of _data["interestedCount"])
                    this.interestedCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["eventType"])) {
                this.eventType = [] as any;
                for (let item of _data["eventType"])
                    this.eventType!.push(EventType.fromJS(item));
            }
            if (Array.isArray(_data["homepage"])) {
                this.homepage = [] as any;
                for (let item of _data["homepage"])
                    this.homepage!.push(Url.fromJS(item));
            }
            if (Array.isArray(_data["title"])) {
                this.title = [] as any;
                for (let item of _data["title"])
                    this.title!.push(Title.fromJS(item));
            }
            if (Array.isArray(_data["startDateTime"])) {
                this.startDateTime = [] as any;
                for (let item of _data["startDateTime"])
                    this.startDateTime!.push(DateTimestamp.fromJS(item));
            }
            if (Array.isArray(_data["endDateTime"])) {
                this.endDateTime = [] as any;
                for (let item of _data["endDateTime"])
                    this.endDateTime!.push(DateTimestamp.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacebookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.eventId)) {
            data["eventId"] = [];
            for (let item of this.eventId)
                data["eventId"].push(item.toJSON());
        }
        if (Array.isArray(this.description)) {
            data["description"] = [];
            for (let item of this.description)
                data["description"].push(item.toJSON());
        }
        if (Array.isArray(this.goingCount)) {
            data["goingCount"] = [];
            for (let item of this.goingCount)
                data["goingCount"].push(item.toJSON());
        }
        if (Array.isArray(this.interestedCount)) {
            data["interestedCount"] = [];
            for (let item of this.interestedCount)
                data["interestedCount"].push(item.toJSON());
        }
        if (Array.isArray(this.eventType)) {
            data["eventType"] = [];
            for (let item of this.eventType)
                data["eventType"].push(item.toJSON());
        }
        if (Array.isArray(this.homepage)) {
            data["homepage"] = [];
            for (let item of this.homepage)
                data["homepage"].push(item.toJSON());
        }
        if (Array.isArray(this.title)) {
            data["title"] = [];
            for (let item of this.title)
                data["title"].push(item.toJSON());
        }
        if (Array.isArray(this.startDateTime)) {
            data["startDateTime"] = [];
            for (let item of this.startDateTime)
                data["startDateTime"].push(item.toJSON());
        }
        if (Array.isArray(this.endDateTime)) {
            data["endDateTime"] = [];
            for (let item of this.endDateTime)
                data["endDateTime"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An event on Facebook that is hosted by a profile, page or group. */
export interface IFacebookEvent extends IVertex {
    eventId?: EventId[];
    description?: Description[];
    goingCount?: CounterValue[];
    interestedCount?: CounterValue[];
    eventType?: EventType[];
    homepage?: Url[];
    title?: Title[];
    startDateTime?: DateTimestamp[];
    endDateTime?: DateTimestamp[];

    [key: string]: any;
}

/** A group on Facebook */
export class FacebookGroup extends Vertex implements IFacebookGroup {
    groupId?: GroupId[];
    groupType?: Label[];
    topic?: Label[];
    memberCount?: CounterValue[];
    screenName?: ScreenName[];
    homepage?: Url[];
    description?: Description[];
    visibility?: AccountVisibility[];
    creationDate?: DateDto[];

    [key: string]: any;

    constructor(data?: IFacebookGroup) {
        super(data);
        this._discriminator = "FacebookGroup";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["groupId"])) {
                this.groupId = [] as any;
                for (let item of _data["groupId"])
                    this.groupId!.push(GroupId.fromJS(item));
            }
            if (Array.isArray(_data["groupType"])) {
                this.groupType = [] as any;
                for (let item of _data["groupType"])
                    this.groupType!.push(Label.fromJS(item));
            }
            if (Array.isArray(_data["topic"])) {
                this.topic = [] as any;
                for (let item of _data["topic"])
                    this.topic!.push(Label.fromJS(item));
            }
            if (Array.isArray(_data["memberCount"])) {
                this.memberCount = [] as any;
                for (let item of _data["memberCount"])
                    this.memberCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["screenName"])) {
                this.screenName = [] as any;
                for (let item of _data["screenName"])
                    this.screenName!.push(ScreenName.fromJS(item));
            }
            if (Array.isArray(_data["homepage"])) {
                this.homepage = [] as any;
                for (let item of _data["homepage"])
                    this.homepage!.push(Url.fromJS(item));
            }
            if (Array.isArray(_data["description"])) {
                this.description = [] as any;
                for (let item of _data["description"])
                    this.description!.push(Description.fromJS(item));
            }
            if (Array.isArray(_data["visibility"])) {
                this.visibility = [] as any;
                for (let item of _data["visibility"])
                    this.visibility!.push(AccountVisibility.fromJS(item));
            }
            if (Array.isArray(_data["creationDate"])) {
                this.creationDate = [] as any;
                for (let item of _data["creationDate"])
                    this.creationDate!.push(DateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacebookGroup {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.groupId)) {
            data["groupId"] = [];
            for (let item of this.groupId)
                data["groupId"].push(item.toJSON());
        }
        if (Array.isArray(this.groupType)) {
            data["groupType"] = [];
            for (let item of this.groupType)
                data["groupType"].push(item.toJSON());
        }
        if (Array.isArray(this.topic)) {
            data["topic"] = [];
            for (let item of this.topic)
                data["topic"].push(item.toJSON());
        }
        if (Array.isArray(this.memberCount)) {
            data["memberCount"] = [];
            for (let item of this.memberCount)
                data["memberCount"].push(item.toJSON());
        }
        if (Array.isArray(this.screenName)) {
            data["screenName"] = [];
            for (let item of this.screenName)
                data["screenName"].push(item.toJSON());
        }
        if (Array.isArray(this.homepage)) {
            data["homepage"] = [];
            for (let item of this.homepage)
                data["homepage"].push(item.toJSON());
        }
        if (Array.isArray(this.description)) {
            data["description"] = [];
            for (let item of this.description)
                data["description"].push(item.toJSON());
        }
        if (Array.isArray(this.visibility)) {
            data["visibility"] = [];
            for (let item of this.visibility)
                data["visibility"].push(item.toJSON());
        }
        if (Array.isArray(this.creationDate)) {
            data["creationDate"] = [];
            for (let item of this.creationDate)
                data["creationDate"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A group on Facebook */
export interface IFacebookGroup extends IVertex {
    groupId?: GroupId[];
    groupType?: Label[];
    topic?: Label[];
    memberCount?: CounterValue[];
    screenName?: ScreenName[];
    homepage?: Url[];
    description?: Description[];
    visibility?: AccountVisibility[];
    creationDate?: DateDto[];

    [key: string]: any;
}

/** A page on Facebook that is used to represent a company or organization. */
export class FacebookPage extends Account implements IFacebookPage {
    likesCount?: CounterValue[];
    category?: Label[];

    [key: string]: any;

    constructor(data?: IFacebookPage) {
        super(data);
        this._discriminator = "FacebookPage";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["likesCount"])) {
                this.likesCount = [] as any;
                for (let item of _data["likesCount"])
                    this.likesCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["category"])) {
                this.category = [] as any;
                for (let item of _data["category"])
                    this.category!.push(Label.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FacebookPage {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.likesCount)) {
            data["likesCount"] = [];
            for (let item of this.likesCount)
                data["likesCount"].push(item.toJSON());
        }
        if (Array.isArray(this.category)) {
            data["category"] = [];
            for (let item of this.category)
                data["category"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A page on Facebook that is used to represent a company or organization. */
export interface IFacebookPage extends IAccount {
    likesCount?: CounterValue[];
    category?: Label[];

    [key: string]: any;
}

export class Follows extends Edge implements IFollows {

    [key: string]: any;

    constructor(data?: IFollows) {
        super(data);
        this._discriminator = "Follows";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Follows {
        data = typeof data === 'object' ? data : {};
        let result = new Follows();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFollows extends IEdge {

    [key: string]: any;
}

export class FriendOf extends Edge implements IFriendOf {

    [key: string]: any;

    constructor(data?: IFriendOf) {
        super(data);
        this._discriminator = "FriendOf";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): FriendOf {
        data = typeof data === 'object' ? data : {};
        let result = new FriendOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IFriendOf extends IEdge {

    [key: string]: any;
}

/** A person's gender. */
export class Gender implements IGender {
    value!: GenderValue;

    [key: string]: any;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A person's gender. */
export interface IGender {
    value: GenderValue;

    [key: string]: any;
}

export class GeographicCoordinate implements IGeographicCoordinate {
    latitude?: number;
    longitude?: number;

    [key: string]: any;

    constructor(data?: IGeographicCoordinate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.latitude = _data["latitude"];
            this.longitude = _data["longitude"];
        }
    }

    static fromJS(data: any): GeographicCoordinate {
        data = typeof data === 'object' ? data : {};
        let result = new GeographicCoordinate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["latitude"] = this.latitude;
        data["longitude"] = this.longitude;
        return data;
    }
}

export interface IGeographicCoordinate {
    latitude?: number;
    longitude?: number;

    [key: string]: any;
}

export class GeographicLocation implements IGeographicLocation {
    value?: GeographicCoordinate;

    [key: string]: any;

    constructor(data?: IGeographicLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? GeographicCoordinate.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GeographicLocation {
        data = typeof data === 'object' ? data : {};
        let result = new GeographicLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGeographicLocation {
    value?: GeographicCoordinate;

    [key: string]: any;
}

/** An account on Google. The homepage references to a page that contains all the reviews that are written by this account, as Google accounts don't have their own 'profile' page. */
export class GoogleAccount extends Account implements IGoogleAccount {

    [key: string]: any;

    constructor(data?: IGoogleAccount) {
        super(data);
        this._discriminator = "GoogleAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): GoogleAccount {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** An account on Google. The homepage references to a page that contains all the reviews that are written by this account, as Google accounts don't have their own 'profile' page. */
export interface IGoogleAccount extends IAccount {

    [key: string]: any;
}

/** An organization on Google Places, people with a Google account can place reviews for these places. AverageRating is the average rating over all reviews. */
export class GooglePlace extends Account implements IGooglePlace {
    averageRating?: AverageRating[];
    businessStatus?: BusinessStatus[];

    [key: string]: any;

    constructor(data?: IGooglePlace) {
        super(data);
        this._discriminator = "GooglePlace";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["averageRating"])) {
                this.averageRating = [] as any;
                for (let item of _data["averageRating"])
                    this.averageRating!.push(AverageRating.fromJS(item));
            }
            if (Array.isArray(_data["businessStatus"])) {
                this.businessStatus = [] as any;
                for (let item of _data["businessStatus"])
                    this.businessStatus!.push(BusinessStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GooglePlace {
        data = typeof data === 'object' ? data : {};
        let result = new GooglePlace();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.averageRating)) {
            data["averageRating"] = [];
            for (let item of this.averageRating)
                data["averageRating"].push(item.toJSON());
        }
        if (Array.isArray(this.businessStatus)) {
            data["businessStatus"] = [];
            for (let item of this.businessStatus)
                data["businessStatus"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An organization on Google Places, people with a Google account can place reviews for these places. AverageRating is the average rating over all reviews. */
export interface IGooglePlace extends IAccount {
    averageRating?: AverageRating[];
    businessStatus?: BusinessStatus[];

    [key: string]: any;
}

/** A graph of vertices and edges representing entities and their relationships that occur in IRIS open source investigations. Properties of vertices (and sometimes edges) are multi-valued; that is, information provided with regards to or collected on an entity (or relationship) may be expressed multiple times. For instance, a Person may have one or more names or birth dates. */
export class Graph implements IGraph {
    vertices?: Vertex[];
    edges?: Edge[];

    [key: string]: any;

    constructor(data?: IGraph) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["vertices"])) {
                this.vertices = [] as any;
                for (let item of _data["vertices"])
                    this.vertices!.push(Vertex.fromJS(item));
            }
            if (Array.isArray(_data["edges"])) {
                this.edges = [] as any;
                for (let item of _data["edges"])
                    this.edges!.push(Edge.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Graph {
        data = typeof data === 'object' ? data : {};
        let result = new Graph();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.vertices)) {
            data["vertices"] = [];
            for (let item of this.vertices)
                data["vertices"].push(item.toJSON());
        }
        if (Array.isArray(this.edges)) {
            data["edges"] = [];
            for (let item of this.edges)
                data["edges"].push(item.toJSON());
        }
        return data;
    }
}

/** A graph of vertices and edges representing entities and their relationships that occur in IRIS open source investigations. Properties of vertices (and sometimes edges) are multi-valued; that is, information provided with regards to or collected on an entity (or relationship) may be expressed multiple times. For instance, a Person may have one or more names or birth dates. */
export interface IGraph {
    vertices?: Vertex[];
    edges?: Edge[];

    [key: string]: any;
}

/** A system oriented group identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export class GroupId implements IGroupId {
    value!: string;

    [key: string]: any;

    constructor(data?: IGroupId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): GroupId {
        data = typeof data === 'object' ? data : {};
        let result = new GroupId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A system oriented group identifier, e.g. '42' or '775005d4-5dca-466a-87e2-013af5958da9'. */
export interface IGroupId {
    value: string;

    [key: string]: any;
}

/** Indicates that an Account uses the connected resource as an Avatar on it's respective social media platform. */
export class HasAvatar extends Edge implements IHasAvatar {

    [key: string]: any;

    constructor(data?: IHasAvatar) {
        super(data);
        this._discriminator = "HasAvatar";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HasAvatar {
        data = typeof data === 'object' ? data : {};
        let result = new HasAvatar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an Account uses the connected resource as an Avatar on it's respective social media platform. */
export interface IHasAvatar extends IEdge {

    [key: string]: any;
}

/** Indicates that a person has an education. */
export class HasEducation extends Edge implements IHasEducation {

    [key: string]: any;

    constructor(data?: IHasEducation) {
        super(data);
        this._discriminator = "HasEducation";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HasEducation {
        data = typeof data === 'object' ? data : {};
        let result = new HasEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a person has an education. */
export interface IHasEducation extends IEdge {

    [key: string]: any;
}

/** Associates a LegalIdentity to an EmailAddress. */
export class HasEmailAddress extends Edge implements IHasEmailAddress {

    [key: string]: any;

    constructor(data?: IHasEmailAddress) {
        super(data);
        this._discriminator = "HasEmailAddress";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HasEmailAddress {
        data = typeof data === 'object' ? data : {};
        let result = new HasEmailAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Associates a LegalIdentity to an EmailAddress. */
export interface IHasEmailAddress extends IEdge {

    [key: string]: any;
}

/** Associates a LegalIdentity to a PhoneNumber. */
export class HasPhoneNumber extends Edge implements IHasPhoneNumber {

    [key: string]: any;

    constructor(data?: IHasPhoneNumber) {
        super(data);
        this._discriminator = "HasPhoneNumber";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HasPhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new HasPhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Associates a LegalIdentity to a PhoneNumber. */
export interface IHasPhoneNumber extends IEdge {

    [key: string]: any;
}

/** Indicates that an Event is hostedBy an Account. */
export class HostedBy extends Edge implements IHostedBy {

    [key: string]: any;

    constructor(data?: IHostedBy) {
        super(data);
        this._discriminator = "HostedBy";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): HostedBy {
        data = typeof data === 'object' ? data : {};
        let result = new HostedBy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an Event is hostedBy an Account. */
export interface IHostedBy extends IEdge {

    [key: string]: any;
}

/** Information on a person's identification document (e.g. a passport or ID card). */
export class IdentificationDocument implements IIdentificationDocument {
    value?: IdentificationDocumentValue;

    [key: string]: any;

    constructor(data?: IIdentificationDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? IdentificationDocumentValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IdentificationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new IdentificationDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Information on a person's identification document (e.g. a passport or ID card). */
export interface IIdentificationDocument {
    value?: IdentificationDocumentValue;

    [key: string]: any;
}

export class IdentificationDocumentValue implements IIdentificationDocumentValue {
    documentId?: string;

    [key: string]: any;

    constructor(data?: IIdentificationDocumentValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): IdentificationDocumentValue {
        data = typeof data === 'object' ? data : {};
        let result = new IdentificationDocumentValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["documentId"] = this.documentId;
        return data;
    }
}

export interface IIdentificationDocumentValue {
    documentId?: string;

    [key: string]: any;
}

/** Indicates that a Person or Organization is (tentatively) identified as an Account. I.e. the legal identity is operating / controlling the account by for instance logging in as the account, communicating through the account,etc. */
export class IdentifiedAs extends Edge implements IIdentifiedAs {

    [key: string]: any;

    constructor(data?: IIdentifiedAs) {
        super(data);
        this._discriminator = "IdentifiedAs";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): IdentifiedAs {
        data = typeof data === 'object' ? data : {};
        let result = new IdentifiedAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a Person or Organization is (tentatively) identified as an Account. I.e. the legal identity is operating / controlling the account by for instance logging in as the account, communicating through the account,etc. */
export interface IIdentifiedAs extends IEdge {

    [key: string]: any;
}

/** Shows that a vertex indicates a particular vertex (e.g. a RiskIndicator). */
export class Indicates extends Edge implements IIndicates {

    [key: string]: any;

    constructor(data?: IIndicates) {
        super(data);
        this._discriminator = "Indicates";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Indicates {
        data = typeof data === 'object' ? data : {};
        let result = new Indicates();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Shows that a vertex indicates a particular vertex (e.g. a RiskIndicator). */
export interface IIndicates extends IEdge {

    [key: string]: any;
}

/** An account on Instagram, username https://www.instagram.com/{userName}, screenName corresponds to the name of the account home page. */
export class InstagramAccount extends Account implements IInstagramAccount {
    isVerified?: IsVerified[];

    [key: string]: any;

    constructor(data?: IInstagramAccount) {
        super(data);
        this._discriminator = "InstagramAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["isVerified"])) {
                this.isVerified = [] as any;
                for (let item of _data["isVerified"])
                    this.isVerified!.push(IsVerified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InstagramAccount {
        data = typeof data === 'object' ? data : {};
        let result = new InstagramAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.isVerified)) {
            data["isVerified"] = [];
            for (let item of this.isVerified)
                data["isVerified"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An account on Instagram, username https://www.instagram.com/{userName}, screenName corresponds to the name of the account home page. */
export interface IInstagramAccount extends IAccount {
    isVerified?: IsVerified[];

    [key: string]: any;
}

export class IntRange implements IIntRange {
    value?: IntRangeValue;

    [key: string]: any;

    constructor(data?: IIntRange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? IntRangeValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IntRange {
        data = typeof data === 'object' ? data : {};
        let result = new IntRange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIntRange {
    value?: IntRangeValue;

    [key: string]: any;
}

/** A range of integers with the start and end values included. */
export class IntRangeValue implements IIntRangeValue {
    minimum?: number;
    maximum?: number;

    [key: string]: any;

    constructor(data?: IIntRangeValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
        }
    }

    static fromJS(data: any): IntRangeValue {
        data = typeof data === 'object' ? data : {};
        let result = new IntRangeValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        return data;
    }
}

/** A range of integers with the start and end values included. */
export interface IIntRangeValue {
    minimum?: number;
    maximum?: number;

    [key: string]: any;
}

/** Interval between two date-time points (instants in time). */
export class Interval implements IInterval {
    value?: IntervalValue;

    [key: string]: any;

    constructor(data?: IInterval) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? IntervalValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Interval {
        data = typeof data === 'object' ? data : {};
        let result = new Interval();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Interval between two date-time points (instants in time). */
export interface IInterval {
    value?: IntervalValue;

    [key: string]: any;
}

/** With the `startTime` and `endTime` in ISO 8601 time format */
export class IntervalValue implements IIntervalValue {
    startTime?: string;
    endTime?: string;

    [key: string]: any;

    constructor(data?: IIntervalValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
        }
    }

    static fromJS(data: any): IntervalValue {
        data = typeof data === 'object' ? data : {};
        let result = new IntervalValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        return data;
    }
}

/** With the `startTime` and `endTime` in ISO 8601 time format */
export interface IIntervalValue {
    startTime?: string;
    endTime?: string;

    [key: string]: any;
}

/** Boolean indicating if an account is verified or not. */
export class IsVerified implements IIsVerified {
    value!: boolean;

    [key: string]: any;

    constructor(data?: IIsVerified) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IsVerified {
        data = typeof data === 'object' ? data : {};
        let result = new IsVerified();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** Boolean indicating if an account is verified or not. */
export interface IIsVerified {
    value: boolean;

    [key: string]: any;
}

export class Label implements ILabel {
    value!: string;

    [key: string]: any;

    constructor(data?: ILabel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Label {
        data = typeof data === 'object' ? data : {};
        let result = new Label();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface ILabel {
    value: string;

    [key: string]: any;
}

export class LegalIdentity extends Identity implements ILegalIdentity {

    [key: string]: any;

    constructor(data?: ILegalIdentity) {
        super(data);
        this._discriminator = "LegalIdentity";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): LegalIdentity {
        data = typeof data === 'object' ? data : {};
        if (data["_type"] === "Organization") {
            let result = new Organization();
            result.init(data);
            return result;
        }
        if (data["_type"] === "Person") {
            let result = new Person();
            result.init(data);
            return result;
        }
        let result = new LegalIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILegalIdentity extends IIdentity {

    [key: string]: any;
}

/** Indicates that an Account Likes another vertex e.g. another account. */
export class Likes extends Edge implements ILikes {

    [key: string]: any;

    constructor(data?: ILikes) {
        super(data);
        this._discriminator = "Likes";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Likes {
        data = typeof data === 'object' ? data : {};
        let result = new Likes();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an Account Likes another vertex e.g. another account. */
export interface ILikes extends IEdge {

    [key: string]: any;
}

export class LinkedInAccount extends Account implements ILinkedInAccount {

    [key: string]: any;

    constructor(data?: ILinkedInAccount) {
        super(data);
        this._discriminator = "LinkedInAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): LinkedInAccount {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface ILinkedInAccount extends IAccount {

    [key: string]: any;
}

/** A page on LinkedIn that is used to represent a school or company. */
export class LinkedInPage extends Account implements ILinkedInPage {
    employeeCount?: IntRange[];
    industry?: Label[];

    [key: string]: any;

    constructor(data?: ILinkedInPage) {
        super(data);
        this._discriminator = "LinkedInPage";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["employeeCount"])) {
                this.employeeCount = [] as any;
                for (let item of _data["employeeCount"])
                    this.employeeCount!.push(IntRange.fromJS(item));
            }
            if (Array.isArray(_data["industry"])) {
                this.industry = [] as any;
                for (let item of _data["industry"])
                    this.industry!.push(Label.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LinkedInPage {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.employeeCount)) {
            data["employeeCount"] = [];
            for (let item of this.employeeCount)
                data["employeeCount"].push(item.toJSON());
        }
        if (Array.isArray(this.industry)) {
            data["industry"] = [];
            for (let item of this.industry)
                data["industry"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A page on LinkedIn that is used to represent a school or company. */
export interface ILinkedInPage extends IAccount {
    employeeCount?: IntRange[];
    industry?: Label[];

    [key: string]: any;
}

/** Indicates that an education is listed by an account. */
export class ListsEducation extends Edge implements IListsEducation {

    [key: string]: any;

    constructor(data?: IListsEducation) {
        super(data);
        this._discriminator = "ListsEducation";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListsEducation {
        data = typeof data === 'object' ? data : {};
        let result = new ListsEducation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an education is listed by an account. */
export interface IListsEducation extends IEdge {

    [key: string]: any;
}

export class ListsEmployment extends Edge implements IListsEmployment {

    [key: string]: any;

    constructor(data?: IListsEmployment) {
        super(data);
        this._discriminator = "ListsEmployment";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ListsEmployment {
        data = typeof data === 'object' ? data : {};
        let result = new ListsEmployment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IListsEmployment extends IEdge {

    [key: string]: any;
}

/** Indicates that an entity (e.g. a Person) is located at a certain Location (e.g. with an Address). */
export class LocatedAt extends Edge implements ILocatedAt {
    interval?: Interval[];
    timestamp?: DateTimestamp[];

    [key: string]: any;

    constructor(data?: ILocatedAt) {
        super(data);
        this._discriminator = "LocatedAt";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["interval"])) {
                this.interval = [] as any;
                for (let item of _data["interval"])
                    this.interval!.push(Interval.fromJS(item));
            }
            if (Array.isArray(_data["timestamp"])) {
                this.timestamp = [] as any;
                for (let item of _data["timestamp"])
                    this.timestamp!.push(DateTimestamp.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocatedAt {
        data = typeof data === 'object' ? data : {};
        let result = new LocatedAt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.interval)) {
            data["interval"] = [];
            for (let item of this.interval)
                data["interval"].push(item.toJSON());
        }
        if (Array.isArray(this.timestamp)) {
            data["timestamp"] = [];
            for (let item of this.timestamp)
                data["timestamp"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an entity (e.g. a Person) is located at a certain Location (e.g. with an Address). */
export interface ILocatedAt extends IEdge {
    interval?: Interval[];
    timestamp?: DateTimestamp[];

    [key: string]: any;
}

/** A location denoted with an address */
export class Location extends Vertex implements ILocation {
    address?: Address[];
    geographicLocation?: GeographicLocation[];

    [key: string]: any;

    constructor(data?: ILocation) {
        super(data);
        this._discriminator = "Location";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["address"])) {
                this.address = [] as any;
                for (let item of _data["address"])
                    this.address!.push(Address.fromJS(item));
            }
            if (Array.isArray(_data["geographicLocation"])) {
                this.geographicLocation = [] as any;
                for (let item of _data["geographicLocation"])
                    this.geographicLocation!.push(GeographicLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.address)) {
            data["address"] = [];
            for (let item of this.address)
                data["address"].push(item.toJSON());
        }
        if (Array.isArray(this.geographicLocation)) {
            data["geographicLocation"] = [];
            for (let item of this.geographicLocation)
                data["geographicLocation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A location denoted with an address */
export interface ILocation extends IVertex {
    address?: Address[];
    geographicLocation?: GeographicLocation[];

    [key: string]: any;
}

export class MediaType implements IMediaType {
    value?: MediaTypeValue;

    [key: string]: any;

    constructor(data?: IMediaType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? MediaTypeValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MediaType {
        data = typeof data === 'object' ? data : {};
        let result = new MediaType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IMediaType {
    value?: MediaTypeValue;

    [key: string]: any;
}

export class MediaTypeValue implements IMediaTypeValue {
    mediaType!: MediaTypeValueMediaType;

    [key: string]: any;

    constructor(data?: IMediaTypeValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.mediaType = _data["mediaType"];
        }
    }

    static fromJS(data: any): MediaTypeValue {
        data = typeof data === 'object' ? data : {};
        let result = new MediaTypeValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["mediaType"] = this.mediaType;
        return data;
    }
}

export interface IMediaTypeValue {
    mediaType: MediaTypeValueMediaType;

    [key: string]: any;
}

/** Indicates that a vertex mentions a particular entity (e.g. a Person). */
export class Mentions extends Edge implements IMentions {
    matched?: Term[];

    [key: string]: any;

    constructor(data?: IMentions) {
        super(data);
        this._discriminator = "Mentions";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["matched"])) {
                this.matched = [] as any;
                for (let item of _data["matched"])
                    this.matched!.push(Term.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Mentions {
        data = typeof data === 'object' ? data : {};
        let result = new Mentions();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.matched)) {
            data["matched"] = [];
            for (let item of this.matched)
                data["matched"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a vertex mentions a particular entity (e.g. a Person). */
export interface IMentions extends IEdge {
    matched?: Term[];

    [key: string]: any;
}

export class Organization extends LegalIdentity implements IOrganization {
    organizationName?: OrganizationName[];
    foundedDate?: DateDto[];

    [key: string]: any;

    constructor(data?: IOrganization) {
        super(data);
        this._discriminator = "Organization";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["organizationName"])) {
                this.organizationName = [] as any;
                for (let item of _data["organizationName"])
                    this.organizationName!.push(OrganizationName.fromJS(item));
            }
            if (Array.isArray(_data["foundedDate"])) {
                this.foundedDate = [] as any;
                for (let item of _data["foundedDate"])
                    this.foundedDate!.push(DateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.organizationName)) {
            data["organizationName"] = [];
            for (let item of this.organizationName)
                data["organizationName"].push(item.toJSON());
        }
        if (Array.isArray(this.foundedDate)) {
            data["foundedDate"] = [];
            for (let item of this.foundedDate)
                data["foundedDate"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IOrganization extends ILegalIdentity {
    organizationName?: OrganizationName[];
    foundedDate?: DateDto[];

    [key: string]: any;
}

export class OrganizationName implements IOrganizationName {
    value?: OrganizationNameString;

    [key: string]: any;

    constructor(data?: IOrganizationName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? OrganizationNameString.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationName {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrganizationName {
    value?: OrganizationNameString;

    [key: string]: any;
}

export class OrganizationNameString implements IOrganizationNameString {
    value!: string;

    [key: string]: any;

    constructor(data?: IOrganizationNameString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): OrganizationNameString {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationNameString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IOrganizationNameString {
    value: string;

    [key: string]: any;
}

/** Datetime value that can be incomplete. */
export class PartialDateTime implements IPartialDateTime {
    value?: PartialDateTimeValue;

    [key: string]: any;

    constructor(data?: IPartialDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? PartialDateTimeValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PartialDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new PartialDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** Datetime value that can be incomplete. */
export interface IPartialDateTime {
    value?: PartialDateTimeValue;

    [key: string]: any;
}

/** A datetime value of which each of its components are optional. */
export class PartialDateTimeValue implements IPartialDateTimeValue {
    year?: number;
    month?: number;
    week?: number;
    day?: number;
    hour?: number;
    minute?: number;
    second?: number;
    millisecond?: number;
    stringRepresentation?: string;

    [key: string]: any;

    constructor(data?: IPartialDateTimeValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.year = _data["year"];
            this.month = _data["month"];
            this.week = _data["week"];
            this.day = _data["day"];
            this.hour = _data["hour"];
            this.minute = _data["minute"];
            this.second = _data["second"];
            this.millisecond = _data["millisecond"];
            this.stringRepresentation = _data["stringRepresentation"];
        }
    }

    static fromJS(data: any): PartialDateTimeValue {
        data = typeof data === 'object' ? data : {};
        let result = new PartialDateTimeValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["year"] = this.year;
        data["month"] = this.month;
        data["week"] = this.week;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["second"] = this.second;
        data["millisecond"] = this.millisecond;
        data["stringRepresentation"] = this.stringRepresentation;
        return data;
    }
}

/** A datetime value of which each of its components are optional. */
export interface IPartialDateTimeValue {
    year?: number;
    month?: number;
    week?: number;
    day?: number;
    hour?: number;
    minute?: number;
    second?: number;
    millisecond?: number;
    stringRepresentation?: string;

    [key: string]: any;
}

export class Person extends LegalIdentity implements IPerson {
    personName?: PersonName[];
    dateOfBirth?: DateDto[];
    gender?: Gender[];
    nationality?: Country[];
    identificationDocument?: IdentificationDocument[];
    driverLicense?: DriverLicense[];

    [key: string]: any;

    constructor(data?: IPerson) {
        super(data);
        this._discriminator = "Person";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["personName"])) {
                this.personName = [] as any;
                for (let item of _data["personName"])
                    this.personName!.push(PersonName.fromJS(item));
            }
            if (Array.isArray(_data["dateOfBirth"])) {
                this.dateOfBirth = [] as any;
                for (let item of _data["dateOfBirth"])
                    this.dateOfBirth!.push(DateDto.fromJS(item));
            }
            if (Array.isArray(_data["gender"])) {
                this.gender = [] as any;
                for (let item of _data["gender"])
                    this.gender!.push(Gender.fromJS(item));
            }
            if (Array.isArray(_data["nationality"])) {
                this.nationality = [] as any;
                for (let item of _data["nationality"])
                    this.nationality!.push(Country.fromJS(item));
            }
            if (Array.isArray(_data["identificationDocument"])) {
                this.identificationDocument = [] as any;
                for (let item of _data["identificationDocument"])
                    this.identificationDocument!.push(IdentificationDocument.fromJS(item));
            }
            if (Array.isArray(_data["driverLicense"])) {
                this.driverLicense = [] as any;
                for (let item of _data["driverLicense"])
                    this.driverLicense!.push(DriverLicense.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.personName)) {
            data["personName"] = [];
            for (let item of this.personName)
                data["personName"].push(item.toJSON());
        }
        if (Array.isArray(this.dateOfBirth)) {
            data["dateOfBirth"] = [];
            for (let item of this.dateOfBirth)
                data["dateOfBirth"].push(item.toJSON());
        }
        if (Array.isArray(this.gender)) {
            data["gender"] = [];
            for (let item of this.gender)
                data["gender"].push(item.toJSON());
        }
        if (Array.isArray(this.nationality)) {
            data["nationality"] = [];
            for (let item of this.nationality)
                data["nationality"].push(item.toJSON());
        }
        if (Array.isArray(this.identificationDocument)) {
            data["identificationDocument"] = [];
            for (let item of this.identificationDocument)
                data["identificationDocument"].push(item.toJSON());
        }
        if (Array.isArray(this.driverLicense)) {
            data["driverLicense"] = [];
            for (let item of this.driverLicense)
                data["driverLicense"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPerson extends ILegalIdentity {
    personName?: PersonName[];
    dateOfBirth?: DateDto[];
    gender?: Gender[];
    nationality?: Country[];
    identificationDocument?: IdentificationDocument[];
    driverLicense?: DriverLicense[];

    [key: string]: any;
}

export class PersonNameElement implements IPersonNameElement {
    role?: PersonNameElementRole;
    value!: string;

    [key: string]: any;

    constructor(data?: IPersonNameElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.role = _data["role"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PersonNameElement {
        data = typeof data === 'object' ? data : {};
        let result = new PersonNameElement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["role"] = this.role;
        data["value"] = this.value;
        return data;
    }
}

export interface IPersonNameElement {
    role?: PersonNameElementRole;
    value: string;

    [key: string]: any;
}

/** A person name of which the elements (tokens) aren't annotated. Use AnnotatedPersonName when more information is available, e.g. like given and last name are available as separate strings. */
export class PersonNameString extends PersonName implements IPersonNameString {
    value?: string;

    [key: string]: any;

    constructor(data?: IPersonNameString) {
        super(data);
        this._discriminator = "PersonNameString";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PersonNameString {
        data = typeof data === 'object' ? data : {};
        let result = new PersonNameString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        super.toJSON(data);
        return data;
    }
}

/** A person name of which the elements (tokens) aren't annotated. Use AnnotatedPersonName when more information is available, e.g. like given and last name are available as separate strings. */
export interface IPersonNameString extends IPersonName {
    value?: string;

    [key: string]: any;
}

export class PhoneNumber extends Vertex implements IPhoneNumber {
    number?: PhoneNumberString[];
    country?: Country[];

    [key: string]: any;

    constructor(data?: IPhoneNumber) {
        super(data);
        this._discriminator = "PhoneNumber";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["number"])) {
                this.number = [] as any;
                for (let item of _data["number"])
                    this.number!.push(PhoneNumberString.fromJS(item));
            }
            if (Array.isArray(_data["country"])) {
                this.country = [] as any;
                for (let item of _data["country"])
                    this.country!.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.number)) {
            data["number"] = [];
            for (let item of this.number)
                data["number"].push(item.toJSON());
        }
        if (Array.isArray(this.country)) {
            data["country"] = [];
            for (let item of this.country)
                data["country"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPhoneNumber extends IVertex {
    number?: PhoneNumberString[];
    country?: Country[];

    [key: string]: any;
}

export class PhoneNumberString implements IPhoneNumberString {
    value!: string;

    [key: string]: any;

    constructor(data?: IPhoneNumberString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PhoneNumberString {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IPhoneNumberString {
    value: string;

    [key: string]: any;
}

export class Position implements IPosition {
    value!: string;

    [key: string]: any;

    constructor(data?: IPosition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Position {
        data = typeof data === 'object' ? data : {};
        let result = new Position();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IPosition {
    value: string;

    [key: string]: any;
}

/** Indicates that the Resource is published somewhere. */
export class PostedOn extends Edge implements IPostedOn {

    [key: string]: any;

    constructor(data?: IPostedOn) {
        super(data);
        this._discriminator = "PostedOn";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): PostedOn {
        data = typeof data === 'object' ? data : {};
        let result = new PostedOn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that the Resource is published somewhere. */
export interface IPostedOn extends IEdge {

    [key: string]: any;
}

/** Indicates that the Account published this Resource. */
export class Published extends Edge implements IPublished {

    [key: string]: any;

    constructor(data?: IPublished) {
        super(data);
        this._discriminator = "Published";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): Published {
        data = typeof data === 'object' ? data : {};
        let result = new Published();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that the Account published this Resource. */
export interface IPublished extends IEdge {

    [key: string]: any;
}

/** A rating found on for example a Google review. */
export class Rating implements IRating {
    value?: RatingValue;

    [key: string]: any;

    constructor(data?: IRating) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? RatingValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Rating {
        data = typeof data === 'object' ? data : {};
        let result = new Rating();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** A rating found on for example a Google review. */
export interface IRating {
    value?: RatingValue;

    [key: string]: any;
}

export class ReplyTo extends Edge implements IReplyTo {

    [key: string]: any;

    constructor(data?: IReplyTo) {
        super(data);
        this._discriminator = "ReplyTo";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ReplyTo {
        data = typeof data === 'object' ? data : {};
        let result = new ReplyTo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface IReplyTo extends IEdge {

    [key: string]: any;
}

export class ResourceClassification implements IResourceClassification {
    value?: ResourceClassificationValue;

    [key: string]: any;

    constructor(data?: IResourceClassification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? ResourceClassificationValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResourceClassification {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceClassification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResourceClassification {
    value?: ResourceClassificationValue;

    [key: string]: any;
}

export class ResourceClassificationValue implements IResourceClassificationValue {
    classificationType!: ResourceClassificationValueClassificationType;

    [key: string]: any;

    constructor(data?: IResourceClassificationValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.classificationType = _data["classificationType"];
        }
    }

    static fromJS(data: any): ResourceClassificationValue {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceClassificationValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["classificationType"] = this.classificationType;
        return data;
    }
}

export interface IResourceClassificationValue {
    classificationType: ResourceClassificationValueClassificationType;

    [key: string]: any;
}

/** A review for something (e.g. a GooglePlace). */
export class Review extends Resource implements IReview {
    rating?: Rating[];

    [key: string]: any;

    constructor(data?: IReview) {
        super(data);
        this._discriminator = "Review";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["rating"])) {
                this.rating = [] as any;
                for (let item of _data["rating"])
                    this.rating!.push(Rating.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Review {
        data = typeof data === 'object' ? data : {};
        let result = new Review();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.rating)) {
            data["rating"] = [];
            for (let item of this.rating)
                data["rating"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A review for something (e.g. a GooglePlace). */
export interface IReview extends IResource {
    rating?: Rating[];

    [key: string]: any;
}

/** Indicates that the GooglePlace was reviewed in this Review. */
export class ReviewedIn extends Edge implements IReviewedIn {

    [key: string]: any;

    constructor(data?: IReviewedIn) {
        super(data);
        this._discriminator = "ReviewedIn";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): ReviewedIn {
        data = typeof data === 'object' ? data : {};
        let result = new ReviewedIn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that the GooglePlace was reviewed in this Review. */
export interface IReviewedIn extends IEdge {

    [key: string]: any;
}

export class RiskIndicator extends Vertex implements IRiskIndicator {
    riskCategory?: Label[];
    riskDescription?: Description[];

    [key: string]: any;

    constructor(data?: IRiskIndicator) {
        super(data);
        this._discriminator = "RiskIndicator";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["riskCategory"])) {
                this.riskCategory = [] as any;
                for (let item of _data["riskCategory"])
                    this.riskCategory!.push(Label.fromJS(item));
            }
            if (Array.isArray(_data["riskDescription"])) {
                this.riskDescription = [] as any;
                for (let item of _data["riskDescription"])
                    this.riskDescription!.push(Description.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RiskIndicator {
        data = typeof data === 'object' ? data : {};
        let result = new RiskIndicator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.riskCategory)) {
            data["riskCategory"] = [];
            for (let item of this.riskCategory)
                data["riskCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.riskDescription)) {
            data["riskDescription"] = [];
            for (let item of this.riskDescription)
                data["riskDescription"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRiskIndicator extends IVertex {
    riskCategory?: Label[];
    riskDescription?: Description[];

    [key: string]: any;
}

/** Indicates that a Vertex is the same as another Vertex. */
export class SameAs extends Edge implements ISameAs {

    [key: string]: any;

    constructor(data?: ISameAs) {
        super(data);
        this._discriminator = "SameAs";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): SameAs {
        data = typeof data === 'object' ? data : {};
        let result = new SameAs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that a Vertex is the same as another Vertex. */
export interface ISameAs extends IEdge {

    [key: string]: any;
}

/** A human oriented name of an account, e.g. 'John Doe'. */
export class ScreenName implements IScreenName {
    value!: string;

    [key: string]: any;

    constructor(data?: IScreenName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ScreenName {
        data = typeof data === 'object' ? data : {};
        let result = new ScreenName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A human oriented name of an account, e.g. 'John Doe'. */
export interface IScreenName {
    value: string;

    [key: string]: any;
}

/** Indicates that an education is a study program provided by an organization. */
export class StudyProgramAt extends Edge implements IStudyProgramAt {

    [key: string]: any;

    constructor(data?: IStudyProgramAt) {
        super(data);
        this._discriminator = "StudyProgramAt";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): StudyProgramAt {
        data = typeof data === 'object' ? data : {};
        let result = new StudyProgramAt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

/** Indicates that an education is a study program provided by an organization. */
export interface IStudyProgramAt extends IEdge {

    [key: string]: any;
}

/** A term matched in a Resource. The term may be a single token or a 'phrase'. The term _may_ have an associated Locale. */
export class Term implements ITerm {
    value?: TermValue;

    [key: string]: any;

    constructor(data?: ITerm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"] ? TermValue.fromJS(_data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Term {
        data = typeof data === 'object' ? data : {};
        let result = new Term();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        return data;
    }
}

/** A term matched in a Resource. The term may be a single token or a 'phrase'. The term _may_ have an associated Locale. */
export interface ITerm {
    value?: TermValue;

    [key: string]: any;
}

export class TermValue implements ITermValue {
    value?: string;
    /** Locale with language and region sub tags as defined in https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry (but in all upper case). */
    locale?: string | undefined;

    [key: string]: any;

    constructor(data?: ITermValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
            this.locale = _data["locale"];
        }
    }

    static fromJS(data: any): TermValue {
        data = typeof data === 'object' ? data : {};
        let result = new TermValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        data["locale"] = this.locale;
        return data;
    }
}

export interface ITermValue {
    value?: string;
    /** Locale with language and region sub tags as defined in https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry (but in all upper case). */
    locale?: string | undefined;

    [key: string]: any;
}

/** An account on TikTok, userName corresponds to https://www.tiktok.com/{userName}, screenName corresponds to the name of the account home page. */
export class TiktokAccount extends Account implements ITiktokAccount {
    likes?: CounterValue[];
    isVerified?: IsVerified[];

    [key: string]: any;

    constructor(data?: ITiktokAccount) {
        super(data);
        this._discriminator = "TiktokAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["likes"])) {
                this.likes = [] as any;
                for (let item of _data["likes"])
                    this.likes!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["isVerified"])) {
                this.isVerified = [] as any;
                for (let item of _data["isVerified"])
                    this.isVerified!.push(IsVerified.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TiktokAccount {
        data = typeof data === 'object' ? data : {};
        let result = new TiktokAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.likes)) {
            data["likes"] = [];
            for (let item of this.likes)
                data["likes"].push(item.toJSON());
        }
        if (Array.isArray(this.isVerified)) {
            data["isVerified"] = [];
            for (let item of this.isVerified)
                data["isVerified"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An account on TikTok, userName corresponds to https://www.tiktok.com/{userName}, screenName corresponds to the name of the account home page. */
export interface ITiktokAccount extends IAccount {
    likes?: CounterValue[];
    isVerified?: IsVerified[];

    [key: string]: any;
}

export class Title implements ITitle {
    value!: string;

    [key: string]: any;

    constructor(data?: ITitle) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Title {
        data = typeof data === 'object' ? data : {};
        let result = new Title();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface ITitle {
    value: string;

    [key: string]: any;
}

export class TwitterAccount extends Account implements ITwitterAccount {

    [key: string]: any;

    constructor(data?: ITwitterAccount) {
        super(data);
        this._discriminator = "TwitterAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any): TwitterAccount {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITwitterAccount extends IAccount {

    [key: string]: any;
}

export class Url implements IUrl {
    value!: string;

    [key: string]: any;

    constructor(data?: IUrl) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Url {
        data = typeof data === 'object' ? data : {};
        let result = new Url();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

export interface IUrl {
    value: string;

    [key: string]: any;
}

/** A name of an account in the 'user name space' of a platform, e.g. 'john.doe.5' or 'james_kirk'. Often used e.g. in url's or through a user referencing system like on twitter (@james_kirk). Note that a user name may or may not correspond to a user name used to log into an account if a user name is even used for that purpose at all. */
export class UserName implements IUserName {
    value!: string;

    [key: string]: any;

    constructor(data?: IUserName) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UserName {
        data = typeof data === 'object' ? data : {};
        let result = new UserName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["value"] = this.value;
        return data;
    }
}

/** A name of an account in the 'user name space' of a platform, e.g. 'john.doe.5' or 'james_kirk'. Often used e.g. in url's or through a user referencing system like on twitter (@james_kirk). Note that a user name may or may not correspond to a user name used to log into an account if a user name is even used for that purpose at all. */
export interface IUserName {
    value: string;

    [key: string]: any;
}

/** A pair of (references to) two vertices in the request or response body. */
export class VertexPair implements IVertexPair {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    left?: string;
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    right?: string;

    [key: string]: any;

    constructor(data?: IVertexPair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.left = _data["left"];
            this.right = _data["right"];
        }
    }

    static fromJS(data: any): VertexPair {
        data = typeof data === 'object' ? data : {};
        let result = new VertexPair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["left"] = this.left;
        data["right"] = this.right;
        return data;
    }
}

/** A pair of (references to) two vertices in the request or response body. */
export interface IVertexPair {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    left?: string;
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    right?: string;

    [key: string]: any;
}

/** A website, e.g. nu.nl or 4chan.org. */
export class Website extends Vertex implements IWebsite {
    homepage?: Url[];
    title?: Title[];
    description?: Description[];

    [key: string]: any;

    constructor(data?: IWebsite) {
        super(data);
        this._discriminator = "Website";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["homepage"])) {
                this.homepage = [] as any;
                for (let item of _data["homepage"])
                    this.homepage!.push(Url.fromJS(item));
            }
            if (Array.isArray(_data["title"])) {
                this.title = [] as any;
                for (let item of _data["title"])
                    this.title!.push(Title.fromJS(item));
            }
            if (Array.isArray(_data["description"])) {
                this.description = [] as any;
                for (let item of _data["description"])
                    this.description!.push(Description.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Website {
        data = typeof data === 'object' ? data : {};
        let result = new Website();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.homepage)) {
            data["homepage"] = [];
            for (let item of this.homepage)
                data["homepage"].push(item.toJSON());
        }
        if (Array.isArray(this.title)) {
            data["title"] = [];
            for (let item of this.title)
                data["title"].push(item.toJSON());
        }
        if (Array.isArray(this.description)) {
            data["description"] = [];
            for (let item of this.description)
                data["description"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** A website, e.g. nu.nl or 4chan.org. */
export interface IWebsite extends IVertex {
    homepage?: Url[];
    title?: Title[];
    description?: Description[];

    [key: string]: any;
}

/** An account on YouTube, accountId corresponds to https://www.youtube.com/channel/{accountId}, userName corresponds to https://www.youtube.com/username/{userName}, screenName corresponds to the name of the account home page. */
export class YouTubeAccount extends Account implements IYouTubeAccount {
    viewCount?: CounterValue[];
    isVerified?: IsVerified[];
    creationDate?: DateDto[];

    [key: string]: any;

    constructor(data?: IYouTubeAccount) {
        super(data);
        this._discriminator = "YouTubeAccount";
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["viewCount"])) {
                this.viewCount = [] as any;
                for (let item of _data["viewCount"])
                    this.viewCount!.push(CounterValue.fromJS(item));
            }
            if (Array.isArray(_data["isVerified"])) {
                this.isVerified = [] as any;
                for (let item of _data["isVerified"])
                    this.isVerified!.push(IsVerified.fromJS(item));
            }
            if (Array.isArray(_data["creationDate"])) {
                this.creationDate = [] as any;
                for (let item of _data["creationDate"])
                    this.creationDate!.push(DateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): YouTubeAccount {
        data = typeof data === 'object' ? data : {};
        let result = new YouTubeAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.viewCount)) {
            data["viewCount"] = [];
            for (let item of this.viewCount)
                data["viewCount"].push(item.toJSON());
        }
        if (Array.isArray(this.isVerified)) {
            data["isVerified"] = [];
            for (let item of this.isVerified)
                data["isVerified"].push(item.toJSON());
        }
        if (Array.isArray(this.creationDate)) {
            data["creationDate"] = [];
            for (let item of this.creationDate)
                data["creationDate"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

/** An account on YouTube, accountId corresponds to https://www.youtube.com/channel/{accountId}, userName corresponds to https://www.youtube.com/username/{userName}, screenName corresponds to the name of the account home page. */
export interface IYouTubeAccount extends IAccount {
    viewCount?: CounterValue[];
    isVerified?: IsVerified[];
    creationDate?: DateDto[];

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class ConnectResult implements IConnectResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IConnectResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ConnectResult {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IConnectResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a connect investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class ConnectStatus implements IConnectStatus {
    result?: ConnectResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IConnectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? ConnectResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): ConnectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ConnectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a connect investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IConnectStatus {
    result?: ConnectResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** An error has occurred. This object provides an error message which gives insight as to what went wrong */
export class ErrorDto implements IErrorDto {
    errorMessage?: string;

    [key: string]: any;

    constructor(data?: IErrorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.errorMessage = _data["errorMessage"];
        }
    }

    static fromJS(data: any): ErrorDto {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["errorMessage"] = this.errorMessage;
        return data;
    }
}

/** An error has occurred. This object provides an error message which gives insight as to what went wrong */
export interface IErrorDto {
    errorMessage?: string;

    [key: string]: any;
}

/** The current status of an investigation: Either an error has occurred or the finished flag is set to the finished state of the requested investigation */
export class InvestigationStatus implements IInvestigationStatus {
    /** Whether the investigation has finished executing, either successfully or erroneously */
    finished?: boolean;
    error?: ErrorDto;

    [key: string]: any;

    constructor(data?: IInvestigationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.finished = _data["finished"];
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvestigationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new InvestigationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["finished"] = this.finished;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data;
    }
}

/** The current status of an investigation: Either an error has occurred or the finished flag is set to the finished state of the requested investigation */
export interface IInvestigationStatus {
    /** Whether the investigation has finished executing, either successfully or erroneously */
    finished?: boolean;
    error?: ErrorDto;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class ContactResult implements IContactResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IContactResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContactResult {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IContactResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a contact investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class ContactStatus implements IContactStatus {
    result?: ContactResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IContactStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? ContactResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): ContactStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ContactStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a contact investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IContactStatus {
    result?: ContactResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The 'scope' of a contact investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export class ContactScope implements IContactScope {
    graph!: Graph;
    subjects!: VertexReference[];
    countries!: string[];
    emailSearch?: boolean;

    [key: string]: any;

    constructor(data?: IContactScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subjects = [];
            this.countries = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(VertexReference.fromJS(item));
            }
            if (Array.isArray(_data["countries"])) {
                this.countries = [] as any;
                for (let item of _data["countries"])
                    this.countries!.push(item);
            }
            this.emailSearch = _data["emailSearch"];
        }
    }

    static fromJS(data: any): ContactScope {
        data = typeof data === 'object' ? data : {};
        let result = new ContactScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        if (Array.isArray(this.countries)) {
            data["countries"] = [];
            for (let item of this.countries)
                data["countries"].push(item);
        }
        data["emailSearch"] = this.emailSearch;
        return data;
    }
}

/** The 'scope' of a contact investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export interface IContactScope {
    graph: Graph;
    subjects: VertexReference[];
    countries: string[];
    emailSearch?: boolean;

    [key: string]: any;
}

/** A reference to a vertex in the request or response body. */
export class VertexReference implements IVertexReference {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    vertex!: string;

    [key: string]: any;

    constructor(data?: IVertexReference) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.vertex = _data["vertex"];
        }
    }

    static fromJS(data: any): VertexReference {
        data = typeof data === 'object' ? data : {};
        let result = new VertexReference();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["vertex"] = this.vertex;
        return data;
    }
}

/** A reference to a vertex in the request or response body. */
export interface IVertexReference {
    /** Represents an entity (a person, facebook account, web resource, etc.) and its properties. */
    vertex: string;

    [key: string]: any;
}

/** The scope of a CSE Risk investigation: the (background) information available on the investigation subject(s) as a graph, a list of one or more subjects to investigate and options indicating whether to run specific sub-investigations (all available options default to false). */
export class CSERiskScope implements ICSERiskScope {
    graph!: Graph;
    subjects!: VertexReference[];
    /** Enable or disable the Darknet Username check (defaults to false). */
    darknetUsername?: boolean | undefined;
    /** Enable or disable the Access to children check (defaults to false). */
    accessToChildren?: boolean | undefined;
    /** Enable or disable the scouting Risk check (defaults to false). */
    scoutingRisk?: boolean | undefined;

    [key: string]: any;

    constructor(data?: ICSERiskScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subjects = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(VertexReference.fromJS(item));
            }
            this.darknetUsername = _data["darknetUsername"];
            this.accessToChildren = _data["accessToChildren"];
            this.scoutingRisk = _data["scoutingRisk"];
        }
    }

    static fromJS(data: any): CSERiskScope {
        data = typeof data === 'object' ? data : {};
        let result = new CSERiskScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        data["darknetUsername"] = this.darknetUsername;
        data["accessToChildren"] = this.accessToChildren;
        data["scoutingRisk"] = this.scoutingRisk;
        return data;
    }
}

/** The scope of a CSE Risk investigation: the (background) information available on the investigation subject(s) as a graph, a list of one or more subjects to investigate and options indicating whether to run specific sub-investigations (all available options default to false). */
export interface ICSERiskScope {
    graph: Graph;
    subjects: VertexReference[];
    /** Enable or disable the Darknet Username check (defaults to false). */
    darknetUsername?: boolean | undefined;
    /** Enable or disable the Access to children check (defaults to false). */
    accessToChildren?: boolean | undefined;
    /** Enable or disable the scouting Risk check (defaults to false). */
    scoutingRisk?: boolean | undefined;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class CSERiskResult implements ICSERiskResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: ICSERiskResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CSERiskResult {
        data = typeof data === 'object' ? data : {};
        let result = new CSERiskResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface ICSERiskResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a CSE Risk check: a result or an error if the execution completed or both are null if the execution has not completed. */
export class CSERiskStatus implements ICSERiskStatus {
    result?: CSERiskResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: ICSERiskStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? CSERiskResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): CSERiskStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CSERiskStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a CSE Risk check: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface ICSERiskStatus {
    result?: CSERiskResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class FacebookAccountCheckResult implements IFacebookAccountCheckResult {
    accountAvailabilityStatus?: FacebookAccountCheckResultAccountAvailabilityStatus;
    investigationPerformedTimestampMilliseconds?: number;

    [key: string]: any;

    constructor(data?: IFacebookAccountCheckResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.accountAvailabilityStatus = _data["accountAvailabilityStatus"];
            this.investigationPerformedTimestampMilliseconds = _data["investigationPerformedTimestampMilliseconds"];
        }
    }

    static fromJS(data: any): FacebookAccountCheckResult {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookAccountCheckResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["accountAvailabilityStatus"] = this.accountAvailabilityStatus;
        data["investigationPerformedTimestampMilliseconds"] = this.investigationPerformedTimestampMilliseconds;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IFacebookAccountCheckResult {
    accountAvailabilityStatus?: FacebookAccountCheckResultAccountAvailabilityStatus;
    investigationPerformedTimestampMilliseconds?: number;

    [key: string]: any;
}

export class FacebookAccountStatusCheckExecutionStatus implements IFacebookAccountStatusCheckExecutionStatus {
    result?: FacebookAccountCheckResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IFacebookAccountStatusCheckExecutionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? FacebookAccountCheckResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): FacebookAccountStatusCheckExecutionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookAccountStatusCheckExecutionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

export interface IFacebookAccountStatusCheckExecutionStatus {
    result?: FacebookAccountCheckResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The 'scope' of a facebook detail investigation. */
export class FacebookDetailScope implements IFacebookDetailScope {
    /** The url, accountId or username to investigate. */
    subject!: string;
    /** Whether to retrieve basic profile information, default true */
    basicInfo?: boolean;
    /** Whether to retrieve work and education, default true */
    workAndEducation?: boolean;
    /** Whether to retrieve checkins, default false */
    checkins?: boolean;
    /** Whether to retrieve likes, default false */
    likes?: boolean;

    [key: string]: any;

    constructor(data?: IFacebookDetailScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.subject = _data["subject"];
            this.basicInfo = _data["basicInfo"];
            this.workAndEducation = _data["workAndEducation"];
            this.checkins = _data["checkins"];
            this.likes = _data["likes"];
        }
    }

    static fromJS(data: any): FacebookDetailScope {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookDetailScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["subject"] = this.subject;
        data["basicInfo"] = this.basicInfo;
        data["workAndEducation"] = this.workAndEducation;
        data["checkins"] = this.checkins;
        data["likes"] = this.likes;
        return data;
    }
}

/** The 'scope' of a facebook detail investigation. */
export interface IFacebookDetailScope {
    /** The url, accountId or username to investigate. */
    subject: string;
    /** Whether to retrieve basic profile information, default true */
    basicInfo?: boolean;
    /** Whether to retrieve work and education, default true */
    workAndEducation?: boolean;
    /** Whether to retrieve checkins, default false */
    checkins?: boolean;
    /** Whether to retrieve likes, default false */
    likes?: boolean;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class FacebookResult implements IFacebookResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IFacebookResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FacebookResult {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IFacebookResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a Facebook investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class FacebookStatus implements IFacebookStatus {
    result?: FacebookResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IFacebookStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? FacebookResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): FacebookStatus {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a Facebook investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IFacebookStatus {
    result?: FacebookResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The 'scope' of a facebook event detail investigation. */
export class EventDetailScope implements IEventDetailScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IEventDetailScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): EventDetailScope {
        data = typeof data === 'object' ? data : {};
        let result = new EventDetailScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The 'scope' of a facebook event detail investigation. */
export interface IEventDetailScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The arguments for scraping posts from an event. */
export class EventPostsScope implements IEventPostsScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IEventPostsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): EventPostsScope {
        data = typeof data === 'object' ? data : {};
        let result = new EventPostsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The arguments for scraping posts from an event. */
export interface IEventPostsScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The 'scope' of a facebook event search investigation. */
export class EventSearchScope implements IEventSearchScope {
    /** The keyword to use while searching for events. */
    searchTerm!: string;
    /** The number of search results to fetch. */
    limit?: number;

    [key: string]: any;

    constructor(data?: IEventSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.searchTerm = _data["searchTerm"];
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): EventSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new EventSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["searchTerm"] = this.searchTerm;
        data["limit"] = this.limit;
        return data;
    }
}

/** The 'scope' of a facebook event search investigation. */
export interface IEventSearchScope {
    /** The keyword to use while searching for events. */
    searchTerm: string;
    /** The number of search results to fetch. */
    limit?: number;

    [key: string]: any;
}

/** The scope of a Facebook friends investigation. */
export class FacebookFriendsScope implements IFacebookFriendsScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The number of friends to fetch. */
    limit?: number;

    [key: string]: any;

    constructor(data?: IFacebookFriendsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.limit = _data["limit"];
        }
    }

    static fromJS(data: any): FacebookFriendsScope {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookFriendsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["limit"] = this.limit;
        return data;
    }
}

/** The scope of a Facebook friends investigation. */
export interface IFacebookFriendsScope {
    graph: Graph;
    subject: VertexReference;
    /** The number of friends to fetch. */
    limit?: number;

    [key: string]: any;
}

/** The 'scope' of a facebook group detail investigation. */
export class GroupDetailScope implements IGroupDetailScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IGroupDetailScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): GroupDetailScope {
        data = typeof data === 'object' ? data : {};
        let result = new GroupDetailScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The 'scope' of a facebook group detail investigation. */
export interface IGroupDetailScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The arguments for scraping posts from a group. */
export class GroupPostsScope implements IGroupPostsScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IGroupPostsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): GroupPostsScope {
        data = typeof data === 'object' ? data : {};
        let result = new GroupPostsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The arguments for scraping posts from a group. */
export interface IGroupPostsScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The 'scope' of a facebook group search investigation. */
export class GroupSearchScope implements IGroupSearchScope {
    /** The keyword to use while searching for groups. */
    searchTerm!: string;
    /** The number of search results to fetch. */
    limit?: number;
    /** Whether the search results should filter public groups. */
    filterPublic?: boolean;

    [key: string]: any;

    constructor(data?: IGroupSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.searchTerm = _data["searchTerm"];
            this.limit = _data["limit"];
            this.filterPublic = _data["filterPublic"];
        }
    }

    static fromJS(data: any): GroupSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new GroupSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["searchTerm"] = this.searchTerm;
        data["limit"] = this.limit;
        data["filterPublic"] = this.filterPublic;
        return data;
    }
}

/** The 'scope' of a facebook group search investigation. */
export interface IGroupSearchScope {
    /** The keyword to use while searching for groups. */
    searchTerm: string;
    /** The number of search results to fetch. */
    limit?: number;
    /** Whether the search results should filter public groups. */
    filterPublic?: boolean;

    [key: string]: any;
}

/** The 'scope' of a facebook page detail investigation. */
export class PageDetailScope implements IPageDetailScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IPageDetailScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): PageDetailScope {
        data = typeof data === 'object' ? data : {};
        let result = new PageDetailScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The 'scope' of a facebook page detail investigation. */
export interface IPageDetailScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The scope of a Facebook page search investigation. */
export class FacebookPageSearchScope implements IFacebookPageSearchScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;

    constructor(data?: IFacebookPageSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.searchLimit = _data["searchLimit"];
        }
    }

    static fromJS(data: any): FacebookPageSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookPageSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["searchLimit"] = this.searchLimit;
        return data;
    }
}

/** The scope of a Facebook page search investigation. */
export interface IFacebookPageSearchScope {
    graph: Graph;
    subject: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;
}

/** The scope of a Facebook profile search investigation. */
export class FacebookProfileSearchScope implements IFacebookProfileSearchScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;

    constructor(data?: IFacebookProfileSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.searchLimit = _data["searchLimit"];
        }
    }

    static fromJS(data: any): FacebookProfileSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookProfileSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["searchLimit"] = this.searchLimit;
        return data;
    }
}

/** The scope of a Facebook profile search investigation. */
export interface IFacebookProfileSearchScope {
    graph: Graph;
    subject: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class GoogleSearchResult implements IGoogleSearchResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IGoogleSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GoogleSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IGoogleSearchResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a Google investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class GoogleStatus implements IGoogleStatus {
    result?: GoogleSearchResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IGoogleStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? GoogleSearchResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): GoogleStatus {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a Google investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IGoogleStatus {
    result?: GoogleSearchResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The scope of a Google search investigation. */
export class GoogleSearchScope implements IGoogleSearchScope {
    /** The keyword to use while searching on Google. */
    searchTerm!: string;
    /** The search results limit, no more results will be returned. The maximum search limit is 20. */
    searchLimit?: number;
    /** The country where to search from. */
    searchCountry?: GoogleSearchScopeSearchCountry;
    /** The search results desired language */
    searchLanguage?: GoogleSearchScopeSearchLanguage;

    [key: string]: any;

    constructor(data?: IGoogleSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.searchTerm = _data["searchTerm"];
            this.searchLimit = _data["searchLimit"];
            this.searchCountry = _data["searchCountry"];
            this.searchLanguage = _data["searchLanguage"];
        }
    }

    static fromJS(data: any): GoogleSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["searchTerm"] = this.searchTerm;
        data["searchLimit"] = this.searchLimit;
        data["searchCountry"] = this.searchCountry;
        data["searchLanguage"] = this.searchLanguage;
        return data;
    }
}

/** The scope of a Google search investigation. */
export interface IGoogleSearchScope {
    /** The keyword to use while searching on Google. */
    searchTerm: string;
    /** The search results limit, no more results will be returned. The maximum search limit is 20. */
    searchLimit?: number;
    /** The country where to search from. */
    searchCountry?: GoogleSearchScopeSearchCountry;
    /** The search results desired language */
    searchLanguage?: GoogleSearchScopeSearchLanguage;

    [key: string]: any;
}

/** The 'scope' of an Instagram profile details investigation. */
export class InstagramProfileDetailsScope implements IInstagramProfileDetailsScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IInstagramProfileDetailsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): InstagramProfileDetailsScope {
        data = typeof data === 'object' ? data : {};
        let result = new InstagramProfileDetailsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The 'scope' of an Instagram profile details investigation. */
export interface IInstagramProfileDetailsScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class InstagramResult implements IInstagramResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IInstagramResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstagramResult {
        data = typeof data === 'object' ? data : {};
        let result = new InstagramResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IInstagramResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of an Instagram investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class InstagramStatus implements IInstagramStatus {
    result?: InstagramResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IInstagramStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? InstagramResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): InstagramStatus {
        data = typeof data === 'object' ? data : {};
        let result = new InstagramStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of an Instagram investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IInstagramStatus {
    result?: InstagramResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The scope of an Instagram profile search investigation. */
export class InstagramProfileSearchScope implements IInstagramProfileSearchScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;

    constructor(data?: IInstagramProfileSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.searchLimit = _data["searchLimit"];
        }
    }

    static fromJS(data: any): InstagramProfileSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new InstagramProfileSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["searchLimit"] = this.searchLimit;
        return data;
    }
}

/** The scope of an Instagram profile search investigation. */
export interface IInstagramProfileSearchScope {
    graph: Graph;
    subject: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 50. */
    searchLimit?: number;

    [key: string]: any;
}

/** The 'scope' of a linkedin detail investigation. */
export class LinkedInDetailScope implements ILinkedInDetailScope {
    /** The url, accountId or username to investigate. */
    subject!: string;
    /** Whether to retrieve basic profile information, default true */
    basicInfo?: boolean;
    /** Whether to retrieve work, default true */
    work?: boolean;
    /** Whether to retrieve education, default true */
    education?: boolean;

    [key: string]: any;

    constructor(data?: ILinkedInDetailScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.subject = _data["subject"];
            this.basicInfo = _data["basicInfo"];
            this.work = _data["work"];
            this.education = _data["education"];
        }
    }

    static fromJS(data: any): LinkedInDetailScope {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInDetailScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["subject"] = this.subject;
        data["basicInfo"] = this.basicInfo;
        data["work"] = this.work;
        data["education"] = this.education;
        return data;
    }
}

/** The 'scope' of a linkedin detail investigation. */
export interface ILinkedInDetailScope {
    /** The url, accountId or username to investigate. */
    subject: string;
    /** Whether to retrieve basic profile information, default true */
    basicInfo?: boolean;
    /** Whether to retrieve work, default true */
    work?: boolean;
    /** Whether to retrieve education, default true */
    education?: boolean;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class LinkedInResult implements ILinkedInResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: ILinkedInResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LinkedInResult {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface ILinkedInResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a LinkedIn investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class LinkedInStatus implements ILinkedInStatus {
    result?: LinkedInResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: ILinkedInStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? LinkedInResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): LinkedInStatus {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a LinkedIn investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface ILinkedInStatus {
    result?: LinkedInResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The 'scope' of a LinkedIn profile search investigation. */
export class LinkedInProfileSearchScope implements ILinkedInProfileSearchScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 10. */
    searchLimit?: number;
    /** Look up the details of the found profiles. */
    lookupDetails?: boolean;

    [key: string]: any;

    constructor(data?: ILinkedInProfileSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.searchLimit = _data["searchLimit"];
            this.lookupDetails = _data["lookupDetails"];
        }
    }

    static fromJS(data: any): LinkedInProfileSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedInProfileSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["searchLimit"] = this.searchLimit;
        data["lookupDetails"] = this.lookupDetails;
        return data;
    }
}

/** The 'scope' of a LinkedIn profile search investigation. */
export interface ILinkedInProfileSearchScope {
    graph: Graph;
    subject: VertexReference;
    /** The search results limit, no more results will be returned. The maximum search limit is 10. */
    searchLimit?: number;
    /** Look up the details of the found profiles. */
    lookupDetails?: boolean;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class RiskResult implements IRiskResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IRiskResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RiskResult {
        data = typeof data === 'object' ? data : {};
        let result = new RiskResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IRiskResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a risk investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class RiskStatus implements IRiskStatus {
    result?: RiskResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IRiskStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? RiskResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): RiskStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RiskStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a risk investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IRiskStatus {
    result?: RiskResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** Represents an area of interest for risk analysis that is composed of a locale (a language and a country) and a risk category. */
export class RiskInterest implements IRiskInterest {
    /** Locale with language and region sub tags as defined in https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry (but in all upper case) to target in the investigation. */
    locale!: string;
    /** A risk category to target in the investigation. */
    category!: string;

    [key: string]: any;

    constructor(data?: IRiskInterest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.locale = _data["locale"];
            this.category = _data["category"];
        }
    }

    static fromJS(data: any): RiskInterest {
        data = typeof data === 'object' ? data : {};
        let result = new RiskInterest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["locale"] = this.locale;
        data["category"] = this.category;
        return data;
    }
}

/** Represents an area of interest for risk analysis that is composed of a locale (a language and a country) and a risk category. */
export interface IRiskInterest {
    /** Locale with language and region sub tags as defined in https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry (but in all upper case) to target in the investigation. */
    locale: string;
    /** A risk category to target in the investigation. */
    category: string;

    [key: string]: any;
}

/** The 'scope' of a risk investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export class RiskScope implements IRiskScope {
    graph!: Graph;
    subjects!: VertexReference[];
    /** The areas of interest (locales and categories) to target in the Risk Analysis investigation. */
    interests!: RiskInterest[];
    /** Whether to investigate risks found on the web in general. */
    web?: boolean;
    /** Whether to investigate risks on facebook. */
    facebook?: boolean;
    /** Whether to investigate risks on twitter. */
    twitter?: boolean;
    /** Whether to investigate risks on instagram. */
    instagram?: boolean;
    /** Whether to investigate risks on youtube. */
    youtube?: boolean;
    /** Whether to investigate risks on linkedin. */
    linkedIn?: boolean;
    /** Whether to investigate risks on google places (only available for organizations). */
    googlePlaces?: boolean;

    [key: string]: any;

    constructor(data?: IRiskScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subjects = [];
            this.interests = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(VertexReference.fromJS(item));
            }
            if (Array.isArray(_data["interests"])) {
                this.interests = [] as any;
                for (let item of _data["interests"])
                    this.interests!.push(RiskInterest.fromJS(item));
            }
            this.web = _data["web"];
            this.facebook = _data["facebook"];
            this.twitter = _data["twitter"];
            this.instagram = _data["instagram"];
            this.youtube = _data["youtube"];
            this.linkedIn = _data["linkedIn"];
            this.googlePlaces = _data["googlePlaces"];
        }
    }

    static fromJS(data: any): RiskScope {
        data = typeof data === 'object' ? data : {};
        let result = new RiskScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        if (Array.isArray(this.interests)) {
            data["interests"] = [];
            for (let item of this.interests)
                data["interests"].push(item.toJSON());
        }
        data["web"] = this.web;
        data["facebook"] = this.facebook;
        data["twitter"] = this.twitter;
        data["instagram"] = this.instagram;
        data["youtube"] = this.youtube;
        data["linkedIn"] = this.linkedIn;
        data["googlePlaces"] = this.googlePlaces;
        return data;
    }
}

/** The 'scope' of a risk investigation: the (background) information available on the investigation subjects and a list of pairs of entities to investigate (the subjects). */
export interface IRiskScope {
    graph: Graph;
    subjects: VertexReference[];
    /** The areas of interest (locales and categories) to target in the Risk Analysis investigation. */
    interests: RiskInterest[];
    /** Whether to investigate risks found on the web in general. */
    web?: boolean;
    /** Whether to investigate risks on facebook. */
    facebook?: boolean;
    /** Whether to investigate risks on twitter. */
    twitter?: boolean;
    /** Whether to investigate risks on instagram. */
    instagram?: boolean;
    /** Whether to investigate risks on youtube. */
    youtube?: boolean;
    /** Whether to investigate risks on linkedin. */
    linkedIn?: boolean;
    /** Whether to investigate risks on google places (only available for organizations). */
    googlePlaces?: boolean;

    [key: string]: any;
}

/** The scope of a TikTok profile details investigation. */
export class TiktokProfileDetailsScope implements ITiktokProfileDetailsScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: ITiktokProfileDetailsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): TiktokProfileDetailsScope {
        data = typeof data === 'object' ? data : {};
        let result = new TiktokProfileDetailsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The scope of a TikTok profile details investigation. */
export interface ITiktokProfileDetailsScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class TiktokResult implements ITiktokResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: ITiktokResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TiktokResult {
        data = typeof data === 'object' ? data : {};
        let result = new TiktokResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface ITiktokResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a Tiktok investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class TiktokStatus implements ITiktokStatus {
    result?: TiktokResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: ITiktokStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? TiktokResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): TiktokStatus {
        data = typeof data === 'object' ? data : {};
        let result = new TiktokStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a Tiktok investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface ITiktokStatus {
    result?: TiktokResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The scope of a Tiktok profile search investigation. */
export class TiktokProfileSearchScope implements ITiktokProfileSearchScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: ITiktokProfileSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): TiktokProfileSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new TiktokProfileSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The scope of a Tiktok profile search investigation. */
export interface ITiktokProfileSearchScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The scope of a Web search investigation. */
export class WebSearchScope implements IWebSearchScope {
    graph!: Graph;
    subject!: VertexReference;
    /** The search results limit, no more results will be returned. The default search limit is 20. */
    searchLimit?: number;

    [key: string]: any;

    constructor(data?: IWebSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
            this.searchLimit = _data["searchLimit"];
        }
    }

    static fromJS(data: any): WebSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new WebSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["searchLimit"] = this.searchLimit;
        return data;
    }
}

/** The scope of a Web search investigation. */
export interface IWebSearchScope {
    graph: Graph;
    subject: VertexReference;
    /** The search results limit, no more results will be returned. The default search limit is 20. */
    searchLimit?: number;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class WebSearchResult implements IWebSearchResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IWebSearchResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WebSearchResult {
        data = typeof data === 'object' ? data : {};
        let result = new WebSearchResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IWebSearchResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a Web investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class WebSearchStatus implements IWebSearchStatus {
    result?: WebSearchResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IWebSearchStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? WebSearchResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): WebSearchStatus {
        data = typeof data === 'object' ? data : {};
        let result = new WebSearchStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a Web investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IWebSearchStatus {
    result?: WebSearchResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The scope of a YouTube profile details investigation. */
export class YoutubeProfileDetailsScope implements IYoutubeProfileDetailsScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IYoutubeProfileDetailsScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): YoutubeProfileDetailsScope {
        data = typeof data === 'object' ? data : {};
        let result = new YoutubeProfileDetailsScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The scope of a YouTube profile details investigation. */
export interface IYoutubeProfileDetailsScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

/** The investigation result if the investigation completed successfully. */
export class YoutubeResult implements IYoutubeResult {
    graph?: Graph;

    [key: string]: any;

    constructor(data?: IYoutubeResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : <any>undefined;
        }
    }

    static fromJS(data: any): YoutubeResult {
        data = typeof data === 'object' ? data : {};
        let result = new YoutubeResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        return data;
    }
}

/** The investigation result if the investigation completed successfully. */
export interface IYoutubeResult {
    graph?: Graph;

    [key: string]: any;
}

/** The current status of a Youtube investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export class YoutubeStatus implements IYoutubeStatus {
    result?: YoutubeResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    readonly done?: boolean;

    [key: string]: any;

    constructor(data?: IYoutubeStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.result = _data["result"] ? YoutubeResult.fromJS(_data["result"]) : <any>undefined;
            this.error = _data["error"] ? ErrorDto.fromJS(_data["error"]) : <any>undefined;
            (<any>this).done = _data["done"];
        }
    }

    static fromJS(data: any): YoutubeStatus {
        data = typeof data === 'object' ? data : {};
        let result = new YoutubeStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        data["done"] = this.done;
        return data;
    }
}

/** The current status of a Youtube investigation: a result or an error if the execution completed or both are null if the execution has not completed. */
export interface IYoutubeStatus {
    result?: YoutubeResult;
    error?: ErrorDto;
    /** Whether or not there is a result or an error in the execution status. */
    done?: boolean;

    [key: string]: any;
}

/** The scope of a YouTube profile search investigation. */
export class YoutubeProfileSearchScope implements IYoutubeProfileSearchScope {
    graph!: Graph;
    subject!: VertexReference;

    [key: string]: any;

    constructor(data?: IYoutubeProfileSearchScope) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.graph = new Graph();
            this.subject = new VertexReference();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.graph = _data["graph"] ? Graph.fromJS(_data["graph"]) : new Graph();
            this.subject = _data["subject"] ? VertexReference.fromJS(_data["subject"]) : new VertexReference();
        }
    }

    static fromJS(data: any): YoutubeProfileSearchScope {
        data = typeof data === 'object' ? data : {};
        let result = new YoutubeProfileSearchScope();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["graph"] = this.graph ? this.graph.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        return data;
    }
}

/** The scope of a YouTube profile search investigation. */
export interface IYoutubeProfileSearchScope {
    graph: Graph;
    subject: VertexReference;

    [key: string]: any;
}

export enum AccountStatusValue {
    ONLINE = "ONLINE",
    OFFLINE = "OFFLINE",
    NOT_FOUND = "NOT_FOUND",
}

export enum AccountVisibilityValue {
    PUBLIC = "PUBLIC",
    PRIVATE = "PRIVATE",
}

export enum AddressElementRole {
    STREET_NAME = "STREET_NAME",
    HOUSE_NUMBER_PART = "HOUSE_NUMBER_PART",
    STREET_ADDRESS = "STREET_ADDRESS",
    POSTAL_CODE = "POSTAL_CODE",
    LOCALITY = "LOCALITY",
    PROVINCE = "PROVINCE",
    STATE = "STATE",
    COUNTRY_NAME = "COUNTRY_NAME",
    COUNTRY_CODE = "COUNTRY_CODE",
}

export enum BusinessStatusValueBusinessStatusType {
    OPERATIONAL = "OPERATIONAL",
    CLOSED_TEMPORARILY = "CLOSED_TEMPORARILY",
    CLOSED_PERMANENTLY = "CLOSED_PERMANENTLY",
}

export enum EmploymentClassificationValueClassificationType {
    RELATED_TO_CHILDREN = "RELATED_TO_CHILDREN",
}

export enum EventTypeValue {
    IN_PERSON = "IN_PERSON",
    ONLINE = "ONLINE",
}

export enum GenderValue {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
}

export enum MediaTypeValueMediaType {
    IMAGE = "IMAGE",
    VIDEO = "VIDEO",
    AUDIO = "AUDIO",
    TEXT = "TEXT",
}

export enum PersonNameElementRole {
    NICK_NAME = "NICK_NAME",
    TITLE = "TITLE",
    GIVEN_NAME = "GIVEN_NAME",
    INITIAL = "INITIAL",
    FAMILY_NAME = "FAMILY_NAME",
}

export enum ResourceClassificationValueClassificationType {
    DEPICTS_CHILDREN = "DEPICTS_CHILDREN",
}

export enum FacebookAccountCheckResultAccountAvailabilityStatus {
    ONLINE = "ONLINE",
    SUSPENDED = "SUSPENDED",
    DISABLED = "DISABLED",
}

export enum GoogleSearchScopeSearchCountry {
    DE = "DE",
    ES = "ES",
    FR = "FR",
    GB = "GB",
    GR = "GR",
    NL = "NL",
    PK = "PK",
    RU = "RU",
    TR = "TR",
    US = "US",
    IT = "IT",
    BE = "BE",
    SE = "SE",
    RO = "RO",
}

export enum GoogleSearchScopeSearchLanguage {
    Ar = "ar",
    De = "de",
    El = "el",
    En = "en",
    Es = "es",
    Fr = "fr",
    Ru = "ru",
    Nl = "nl",
    Tr = "tr",
    Ur = "ur",
    It = "it",
    Sv = "sv",
    Ro = "ro",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
